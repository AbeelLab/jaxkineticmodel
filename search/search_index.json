{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Summary Introduction A package for building, simulating and training kinetic models using Jax/Diffrax. Figure 1: Overview of the training procedure of SBML models being parameterized using techniques from neural differential equations . Installation Alternatively, the jaxkinetic model package can be installed using pip by cloning the repository and from the project folder doing: git clone https://github.com/AbeelLab/jaxkineticmodel.git python -m pip install . TO DO: archive package on pip to make it installable Minimal simulation example from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import matplotlib.pyplot as plt import pandas as pd import jax # define a reaction v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) # add reaction to a JaxKineticModel_Build class + compartment values reactions = [ v1 ] compartment_values = { 'c' : 1 } kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) # setup simulation ts = jnp . linspace ( 0 , 15 , 1000 ) y0 = jnp . array ([ 2 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 ]))) # solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) # plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 2: Simple reaction system simulation. References [1] Arxiv","title":"Home"},{"location":"#summary","text":"","title":"Summary"},{"location":"#introduction","text":"A package for building, simulating and training kinetic models using Jax/Diffrax. Figure 1: Overview of the training procedure of SBML models being parameterized using techniques from neural differential equations .","title":"Introduction"},{"location":"#installation","text":"Alternatively, the jaxkinetic model package can be installed using pip by cloning the repository and from the project folder doing: git clone https://github.com/AbeelLab/jaxkineticmodel.git python -m pip install . TO DO: archive package on pip to make it installable","title":"Installation"},{"location":"#minimal-simulation-example","text":"from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import matplotlib.pyplot as plt import pandas as pd import jax # define a reaction v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) # add reaction to a JaxKineticModel_Build class + compartment values reactions = [ v1 ] compartment_values = { 'c' : 1 } kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) # setup simulation ts = jnp . linspace ( 0 , 15 , 1000 ) y0 = jnp . array ([ 2 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 ]))) # solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) # plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 2: Simple reaction system simulation.","title":"Minimal simulation example"},{"location":"#references","text":"[1] Arxiv","title":"References"},{"location":"SBML/","text":"Loading SBML models SBML loader and simulation SBML models can be loaded and simulated as follows. from jaxkineticmodel.load_sbml.sbml_load import * from jaxkineticmodel.load_sbml.sbml_model import SBMLModel filepath = ( \"../../models/sbml_models/working_models/simple_sbml.xml\" ) # load model from file_path model = SBMLModel ( filepath ) S = model . _get_stoichiometric_matrix () JaxKmodel = model . get_kinetic_model () ts = jnp . linspace ( 0 , 100 , 2000 ) # parameters in sbml can be either global or local parameters. # For gradient descent purposes we want all of them global. params = get_global_parameters ( model . model ) params = { ** model . local_params , ** params } #simulate given the initial conditions defined in the sbml ys = JaxKmodel ( ts = ts , y0 = model . y0 , params = params ) ys = pd . DataFrame ( ys , columns = S . index ) Percentage of similar models Status report on a large collection of SBML models loaded from biomodels and from a benchmark collection [1] . Discrepancies are models where we compared the output from JaxKineticModel to a simulation using tellurium [2] , a popular tool in systems biology. Discrepancies could be there because of numerical differences in the results, or potentially a missing feature in our current implementation (certain event rules are not implemented yet.) Category Number of working models Models working 31 Failing models 2 Discrepancies 5 References [1] Hass, H., Loos, C., Raimundez-Alvarez, E., Timmer, J., Hasenauer, J., & Kreutz, C. (2019). Benchmark problems for dynamic modeling of intracellular processes. Bioinformatics, 35(17), 3073-3082. [2] Choi, K., Medley, J. K., K\u00f6nig, M., Stocking, K., Smith, L., Gu, S., & Sauro, H. M. (2018). Tellurium: an extensible python-based modeling environment for systems and synthetic biology. Biosystems, 171, 74-79.","title":"Loading SBML models"},{"location":"SBML/#loading-sbml-models","text":"","title":"Loading SBML models"},{"location":"SBML/#sbml-loader-and-simulation","text":"SBML models can be loaded and simulated as follows. from jaxkineticmodel.load_sbml.sbml_load import * from jaxkineticmodel.load_sbml.sbml_model import SBMLModel filepath = ( \"../../models/sbml_models/working_models/simple_sbml.xml\" ) # load model from file_path model = SBMLModel ( filepath ) S = model . _get_stoichiometric_matrix () JaxKmodel = model . get_kinetic_model () ts = jnp . linspace ( 0 , 100 , 2000 ) # parameters in sbml can be either global or local parameters. # For gradient descent purposes we want all of them global. params = get_global_parameters ( model . model ) params = { ** model . local_params , ** params } #simulate given the initial conditions defined in the sbml ys = JaxKmodel ( ts = ts , y0 = model . y0 , params = params ) ys = pd . DataFrame ( ys , columns = S . index )","title":"SBML loader and simulation"},{"location":"SBML/#percentage-of-similar-models","text":"Status report on a large collection of SBML models loaded from biomodels and from a benchmark collection [1] . Discrepancies are models where we compared the output from JaxKineticModel to a simulation using tellurium [2] , a popular tool in systems biology. Discrepancies could be there because of numerical differences in the results, or potentially a missing feature in our current implementation (certain event rules are not implemented yet.) Category Number of working models Models working 31 Failing models 2 Discrepancies 5","title":"Percentage of similar models"},{"location":"SBML/#references","text":"[1] Hass, H., Loos, C., Raimundez-Alvarez, E., Timmer, J., Hasenauer, J., & Kreutz, C. (2019). Benchmark problems for dynamic modeling of intracellular processes. Bioinformatics, 35(17), 3073-3082. [2] Choi, K., Medley, J. K., K\u00f6nig, M., Stocking, K., Smith, L., Gu, S., & Sauro, H. M. (2018). Tellurium: an extensible python-based modeling environment for systems and synthetic biology. Biosystems, 171, 74-79.","title":"References"},{"location":"building_models/","text":"Building models Metabolic kinetic modelling The time evolution of metabolic states are often described by a set of Ordinary Differential Equations (ODEs): $$\\frac{dm(t)}{dt}=S\\cdot v(t,m(t),\\theta)$$ \\(S\\) is the stoichiometric matrix that describes the mass balances of a metabolic system. The fluxes \\(v\\) are described by reaction mechanisms, typically of some form like Michaelis-Menten or Hill equations. These mechanisms are parameterized by \\(\\theta\\). By providing the initial values of the metabolic states, the ODEs can be solved using a numerical solver: $$m(T)=m(0)+\\int_0^T S\\cdot v(t,m(t),\\theta)dt$$ We will describe below how you can build your own models that are compatible with Jax/Diffrax [1] . The Reaction object A reaction-centric approach Models can be built in a reaction-centric manner. Initializing a Reaction object requires five inputs: name of the reaction, names of the species involved, stoichiometry of the reaction, compartments of the species involved, and the reaction's mechanism. from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import jax import matplotlib.pyplot as plt import pandas as pd ReactionA = jkm . Reaction ( name = \"ReactionA\" , species = [ 'A' , 'B' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"A\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) The mechanism is another class that describes the flux function, which depends on metabolite states and parameters. Parameters are pointed towards with unique symbols. The reaction object is implemented in a way that own-implemented flux functions can be used. We have also implemented a set of general flux functions that are often used in systems biology. Table of implemented mechanisms Type of Reaction Name (in JAX class) Number of Parameters A \u2192 B Jax_MM_Irrev_Uni 2 A \u2192 B Jax_MM_Irrev_Uni_w_modifiers 2 + modifiers A \u2194 B Jax_MM_Rev_UniUni 4 A \u2192 Jax_MM_Sink 2 A \u2192 Jax_MA_Irrev 1 A \u21d2 Jax_Facilitated_Diffusion 3 A \u21d2 Jax_Diffusion 2 A + B \u2192 C Jax_MM_Irrev_Bi 3 Jax_MM_Irrev_Bi_w_Inhibition 3 Jax_MM_Irrev_Bi_w_modifiers 3 + modifiers A + B \u2194 C + D Jax_MM_Rev_BiBi 6 Jax_MM_Rev_BiBi_w_Inhibition 7 Jax_MM_Rev_BiBi_w_Activation 9 A + B \u2194 C + D Jax_MA_Rev_Bi 2 A \u2194 B + C Jax_MM_Rev_UniBi 5 A + B \u2192 C + D + E Jax_MM_Ordered_BiTri 7 A + B \u2192 C + D Jax_ADH 15 A \u2192 B + C Jax_Hill_Bi_Irreversible_Activation 7 A \u2192 B + C Jax_Hill_Irreversible_Inhibition 7 Building simple models A simple metabolic network example Here, we show an example of how to build kinetic models using the reaction objects described above. We model the following network: Three metabolic fluxes need to be modelled v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) v2 = jkm . Reaction ( name = \"v2\" , species = [ 'm2' , 'm3' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"B_Vmax\" , km_substrate = \"B_Km\" ), ) v3 = jkm . Reaction ( name = \"v3\" , species = [ 'm2' , 'm4' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"C_Vmax\" , km_substrate = \"C_Km\" ), ) reactions = [ v1 , v2 , v3 ] compartment_values = { 'c' : 1 } # initialize the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) print ( kmodel . stoichiometric_matrix ) The stoichiometric matrix is automatically constructed from the reactions. v1 v2 v3 m1 -1.0 0.0 0.0 m2 1.0 -1.0 -1.0 m3 0.0 1.0 0.0 m4 0.0 0.0 1.0 One can first jax.jit the model [2] and solve the ODEs using the diffrax package [1] , which contains many nice numerical solvers. ts = jnp . linspace ( 0 , 10 , 1000 ) y0 = jnp . array ([ 2 , 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 1: ODE simulation. On jit-compiling kinetic models When you simulated a jit-compiled kinetic model for a certain time-range (e.g., jnp.linspace(0,10,1000) and you want to elongate this, it is best to not change the number of timepoints (e.g, jnp.linspace(0,1000,1000) . Otherwise, the kinetic models needs to be recompiled. Boundary conditions Boundary conditions can be either constant or not constant. Both are implemented as a BoundaryCondition class Constant boundary conditions Suppose for the system above, we want to make metabolite \\(m_1\\) a constant boundary condition. We can redefine the species by replacing it with a value kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( \"2\" , constant = True )) print ( kmodel . stoichiometric_matrix ) #recompile and simulate kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) #plot fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 2: ODE simulation with \\(m1=constant\\). Non-constant boundary conditions For non-constant boundary conditions, you can use the BoundaryCondition class as before. You can use for example the interpolation abstract classes from Diffrax . For analytic expression dependent on time t, these can be done as follows: kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '0.5+0.3*sin(t)' )) print ( kmodel . stoichiometric_matrix ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 3: ODE simulation with \\(m1=0+5+0.3*sin(t)\\). Building custom models When building kinetic models, it is not uncommon that \\(\\frac{dm(t)}{dt}\\) is not fully based on the evaluation of \\(S\\cdot v(t)\\). For these cases, one can still use the kinetic mechanisms described above but with a manual setup of the ODEs. We have provided a custom implementation of glycolysis in Custom models as an example. Saving models Coming up References [1] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435. [2] Bradbury, J., Frostig, R., Hawkins, P., Johnson, M. J., Leary, C., Maclaurin, D., ... & Zhang, Q. (2018). JAX: composable transformations of Python+ NumPy programs.","title":"Building models"},{"location":"building_models/#building-models","text":"","title":"Building models"},{"location":"building_models/#metabolic-kinetic-modelling","text":"The time evolution of metabolic states are often described by a set of Ordinary Differential Equations (ODEs): $$\\frac{dm(t)}{dt}=S\\cdot v(t,m(t),\\theta)$$ \\(S\\) is the stoichiometric matrix that describes the mass balances of a metabolic system. The fluxes \\(v\\) are described by reaction mechanisms, typically of some form like Michaelis-Menten or Hill equations. These mechanisms are parameterized by \\(\\theta\\). By providing the initial values of the metabolic states, the ODEs can be solved using a numerical solver: $$m(T)=m(0)+\\int_0^T S\\cdot v(t,m(t),\\theta)dt$$ We will describe below how you can build your own models that are compatible with Jax/Diffrax [1] .","title":"Metabolic kinetic modelling"},{"location":"building_models/#the-reaction-object","text":"","title":"The Reaction object"},{"location":"building_models/#a-reaction-centric-approach","text":"Models can be built in a reaction-centric manner. Initializing a Reaction object requires five inputs: name of the reaction, names of the species involved, stoichiometry of the reaction, compartments of the species involved, and the reaction's mechanism. from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import jax import matplotlib.pyplot as plt import pandas as pd ReactionA = jkm . Reaction ( name = \"ReactionA\" , species = [ 'A' , 'B' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"A\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) The mechanism is another class that describes the flux function, which depends on metabolite states and parameters. Parameters are pointed towards with unique symbols. The reaction object is implemented in a way that own-implemented flux functions can be used. We have also implemented a set of general flux functions that are often used in systems biology.","title":"A reaction-centric approach"},{"location":"building_models/#table-of-implemented-mechanisms","text":"Type of Reaction Name (in JAX class) Number of Parameters A \u2192 B Jax_MM_Irrev_Uni 2 A \u2192 B Jax_MM_Irrev_Uni_w_modifiers 2 + modifiers A \u2194 B Jax_MM_Rev_UniUni 4 A \u2192 Jax_MM_Sink 2 A \u2192 Jax_MA_Irrev 1 A \u21d2 Jax_Facilitated_Diffusion 3 A \u21d2 Jax_Diffusion 2 A + B \u2192 C Jax_MM_Irrev_Bi 3 Jax_MM_Irrev_Bi_w_Inhibition 3 Jax_MM_Irrev_Bi_w_modifiers 3 + modifiers A + B \u2194 C + D Jax_MM_Rev_BiBi 6 Jax_MM_Rev_BiBi_w_Inhibition 7 Jax_MM_Rev_BiBi_w_Activation 9 A + B \u2194 C + D Jax_MA_Rev_Bi 2 A \u2194 B + C Jax_MM_Rev_UniBi 5 A + B \u2192 C + D + E Jax_MM_Ordered_BiTri 7 A + B \u2192 C + D Jax_ADH 15 A \u2192 B + C Jax_Hill_Bi_Irreversible_Activation 7 A \u2192 B + C Jax_Hill_Irreversible_Inhibition 7","title":"Table of implemented mechanisms"},{"location":"building_models/#building-simple-models","text":"","title":"Building simple models"},{"location":"building_models/#a-simple-metabolic-network-example","text":"Here, we show an example of how to build kinetic models using the reaction objects described above. We model the following network: Three metabolic fluxes need to be modelled v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) v2 = jkm . Reaction ( name = \"v2\" , species = [ 'm2' , 'm3' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"B_Vmax\" , km_substrate = \"B_Km\" ), ) v3 = jkm . Reaction ( name = \"v3\" , species = [ 'm2' , 'm4' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"C_Vmax\" , km_substrate = \"C_Km\" ), ) reactions = [ v1 , v2 , v3 ] compartment_values = { 'c' : 1 } # initialize the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) print ( kmodel . stoichiometric_matrix ) The stoichiometric matrix is automatically constructed from the reactions. v1 v2 v3 m1 -1.0 0.0 0.0 m2 1.0 -1.0 -1.0 m3 0.0 1.0 0.0 m4 0.0 0.0 1.0 One can first jax.jit the model [2] and solve the ODEs using the diffrax package [1] , which contains many nice numerical solvers. ts = jnp . linspace ( 0 , 10 , 1000 ) y0 = jnp . array ([ 2 , 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 1: ODE simulation.","title":"A simple metabolic network example"},{"location":"building_models/#on-jit-compiling-kinetic-models","text":"When you simulated a jit-compiled kinetic model for a certain time-range (e.g., jnp.linspace(0,10,1000) and you want to elongate this, it is best to not change the number of timepoints (e.g, jnp.linspace(0,1000,1000) . Otherwise, the kinetic models needs to be recompiled.","title":"On jit-compiling kinetic models"},{"location":"building_models/#boundary-conditions","text":"Boundary conditions can be either constant or not constant. Both are implemented as a BoundaryCondition class","title":"Boundary conditions"},{"location":"building_models/#constant-boundary-conditions","text":"Suppose for the system above, we want to make metabolite \\(m_1\\) a constant boundary condition. We can redefine the species by replacing it with a value kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( \"2\" , constant = True )) print ( kmodel . stoichiometric_matrix ) #recompile and simulate kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) #plot fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 2: ODE simulation with \\(m1=constant\\).","title":"Constant boundary conditions"},{"location":"building_models/#non-constant-boundary-conditions","text":"For non-constant boundary conditions, you can use the BoundaryCondition class as before. You can use for example the interpolation abstract classes from Diffrax . For analytic expression dependent on time t, these can be done as follows: kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '0.5+0.3*sin(t)' )) print ( kmodel . stoichiometric_matrix ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 3: ODE simulation with \\(m1=0+5+0.3*sin(t)\\).","title":"Non-constant boundary conditions"},{"location":"building_models/#building-custom-models","text":"When building kinetic models, it is not uncommon that \\(\\frac{dm(t)}{dt}\\) is not fully based on the evaluation of \\(S\\cdot v(t)\\). For these cases, one can still use the kinetic mechanisms described above but with a manual setup of the ODEs. We have provided a custom implementation of glycolysis in Custom models as an example.","title":"Building custom models"},{"location":"building_models/#saving-models","text":"Coming up","title":"Saving models"},{"location":"building_models/#references","text":"[1] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435. [2] Bradbury, J., Frostig, R., Hawkins, P., Johnson, M. J., Leary, C., Maclaurin, D., ... & Zhang, Q. (2018). JAX: composable transformations of Python+ NumPy programs.","title":"References"},{"location":"glycolysis/","text":"Custom ODE models Not all kinetic model can be drafted only from stoichiometry. There are many empirical laws that might influence reactions in the system of ODEs. Below, we present a reimplemented version [1] of a glycolysis model in Jax with a manually set up of ODEs. Glycolysis model The model consists of 29 metabolites (ODEs), 38 reactions, with in total 141 parameters. The model can also be found in Github/models/manual_implementations and loaded from there. Rate laws Start by loading the required kinetic mechanisms from jaxkineticmodel.kinetic_mechanisms.JaxKineticMechanisms import * from jaxkineticmodel.kinetic_mechanisms.JaxKineticMechanismsCustom import * from jaxkineticmodel.kinetic_mechanisms.JaxKineticModifiers import * Now, we define all reactions in the model. Note that names in substrates and products should match actual species names in the initial conditions. First, lower glycolysis. #upper glycolysis (GLT, HXK, PGI, PFK,ALD,TPI) v_GLT = Jax_Facilitated_Diffusion ( substrate_extracellular = 'ECglucose' , product_intracellular = 'ICglucose' , vmax = \"p_GLT_VmGLT\" , km_internal = 'p_GLT_KmGLTGLCi' , km_external = 'p_GLT_KmGLTGLCo' ) v_HXK = Jax_MM_Rev_BiBi_w_Inhibition ( substrate1 = 'ICATP' , substrate2 = \"ICglucose\" , product1 = \"ICADP\" , product2 = \"ICATP\" , modifier = \"ICT6P\" , vmax = \"p_HXK_Vmax\" , k_equilibrium = \"p_HXK1_Keq\" , km_substrate1 = \"p_HXK1_Katp\" , km_substrate2 = \"p_HXK1_Kglc\" , km_product1 = \"p_HXK1_Kadp\" , km_product2 = \"p_HXK1_Kg6p\" , ki_inhibitor = \"p_HXK1_Kt6p\" ) v_PGI = Jax_MM_Rev_UniUni ( substrate = 'ICG6P' , product = 'ICF6P' , vmax = 'p_PGI1_Vmax' , k_equilibrium = 'p_PGI1_Keq' , km_substrate = 'p_PGI1_Kg6p' , km_product = 'p_PGI1_Kf6p' ) v_PFK = Jax_PFK ( substrate1 = \"ICF6P\" , substrate2 = \"ICATP\" , product1 = \"ICFBP\" , modifier = \"ICAMP\" , vmax = \"p_PFK_Vmax\" , kr_F6P = \"p_PFK_Kf6p\" , kr_ATP = \"p_PFK_Katp\" , gr = \"p_PFK_gR\" , c_ATP = \"p_PFK_Catp\" , ci_ATP = \"p_PFK_Ciatp\" , ci_AMP = \"p_PFK_Camp\" , ci_F26BP = \"p_PFK_Cf26bp\" , ci_F16BP = \"p_PFK_Cf16bp\" , l = \"p_PFK_L\" , kATP = \"p_PFK_Kiatp\" , kAMP = \"p_PFK_Kamp\" , F26BP = \"p_PFK_F26BP\" , kF26BP = \"p_PFK_Kf26bp\" , kF16BP = \"p_PFK_Kf16bp\" ) v_ALD = Jax_MM_Rev_UniBi ( substrate = 'ICFBP' , product1 = 'ICGAP' , product2 = 'ICDHAP' , vmax = \"p_FBA1_Vmax\" , k_equilibrium = \"p_FBA1_Keq\" , km_substrate = \"p_FBA1_Kf16bp\" , km_product1 = \"p_FBA1_Kglyceral3p\" , km_product2 = \"p_FBA1_Kdhap\" ) v_TPI1 = Jax_MM_Rev_UniUni ( substrate = \"ICDHAP\" , product = \"ICGAP\" , vmax = \"p_TPI1_Vmax\" , k_equilibrium = \"p_TPI1_Keq\" , km_substrate = \"p_TPI1_Kdhap\" , km_product = \"p_TPI1_Kglyceral3p\" ) Trehalose cycle #trehalose cycle (NTH1, PGM1, TPS2, TPS1) v_NTH1 = Jax_MM_Irrev_Uni ( substrate = 'ICtreh' , vmax = 'p_NTH1_Vmax' , km_substrate = 'p_NTH1_Ktre' ) v_PGM1 = Jax_MM_Rev_UniUni ( substrate = 'ICG1P' , product = 'ICG6P' , vmax = 'p_PGM1_Vmax' , k_equilibrium = 'p_PGM1_Keq' , km_substrate = 'p_PGM1_Kg1p' , km_product = 'p_PGM1_Kg6p' ) #to do v_TPS1 for 2nd rate law # inhibitor_TPS1=SimpleInhibitor(k_I='p_TPS1_Kpi') activator_TPS1 = SimpleActivator ( k_A = \"p_TPS1_KmF6P\" ) v_TPS1 = Jax_MM_Irrev_Bi_w_Modifiers ( substrate1 = \"ICG6P\" , substrate2 = \"ICG1P\" , modifiers_list = [ 'ICF6P' ], vmax = \"p_TPS1_Vmax\" , km_substrate1 = \"p_TPS1_Kg6p\" , km_substrate2 = \"p_TPS1_Kudp_glc\" , modifiers = [ activator_TPS1 ]) # v_TPS1=Jax_MM_Irrev_Bi(substrate1=\"ICG6P\",substrate2=\"ICG1P\",vmax=\"p_TPS1_Vmax\",km_substrate1=\"p_TPS1_Kg6p\",km_substrate2=\"p_TPS1_Kudp_glc\") v_TPS2 = Jax_MM_Irrev_Bi_w_Inhibition ( substrate = \"ICT6P\" , product = \"ICPHOS\" , vmax = \"p_TPS2_Vmax\" , km_substrate1 = \"p_TPS2_Kt6p\" , ki = \"p_TPS2_Kpi\" ) Lower glycolysis # Lower glycolysis (GAPDH, PGK,PGM,ENO, PDC, ADH) v_GAPDH = Jax_MM_Ordered_Bi_Tri ( substrate1 = \"ICGAP\" , substrate2 = \"ICNAD\" , substrate3 = \"ICPHOS\" , product1 = \"ICBPG\" , product2 = \"ICNADH\" , vmax = \"p_GAPDH_Vmax\" , k_equilibrium = \"p_TDH1_Keq\" , km_substrate1 = \"p_TDH1_Kglyceral3p\" , km_substrate2 = \"p_TDH1_Knad\" , ki = \"p_TDH1_Kpi\" , km_product1 = \"p_TDH1_Kglycerate13bp\" , km_product2 = \"p_TDH1_Knadh\" ) #might exchange this mechanism by a BiBi mechanism, since modeling Phos is a bit too much v_PGK = Jax_MM_Rev_BiBi ( substrate1 = \"ICBPG\" , substrate2 = \"ICADP\" , product1 = \"IC3PG\" , product2 = \"ICATP\" , vmax = \"p_PGK_VmPGK\" , k_equilibrium = \"p_PGK_KeqPGK\" , km_substrate1 = \"p_PGK_KmPGKBPG\" , km_substrate2 = \"p_PGK_KmPGKADP\" , km_product1 = \"p_PGK_KmPGKP3G\" , km_product2 = \"p_PGK_KmPGKATP\" ) v_PGM = Jax_MM_Rev_UniUni ( substrate = \"IC3PG\" , product = \"IC2PG\" , vmax = \"p_PGM_Vm\" , k_equilibrium = \"p_PGM_Keq\" , km_substrate = \"p_PGM_K3pg\" , km_product = \"p_PGM_K2pg\" ) v_ENO = Jax_MM_Rev_UniUni ( substrate = \"IC2PG\" , product = \"ICPEP\" , vmax = \"p_ENO1_Vm\" , k_equilibrium = \"p_ENO1_Keq\" , km_substrate = \"p_ENO1_K2pg\" , km_product = \"p_ENO1_Kpep\" ) v_PYK1 = Jax_Hill_Irreversible_Bi_Activation ( substrate1 = \"ICPEP\" , substrate2 = \"ICADP\" , activator = \"ICFBP\" , product = \"ICATP\" , vmax = \"p_PYK1_Vm\" , hill = \"p_PYK1_hill\" , k_substrate1 = \"p_PYK1_Kpep\" , k_substrate2 = \"p_PYK1_Kadp\" , k_product = \"p_PYK1_Katp\" , k_activator = \"p_PYK1_Kf16bp\" , l = \"p_PYK1_L\" ) v_PDC = Jax_Hill_Irreversible_Inhibition ( substrate = \"ICPYR\" , inhibitor = \"ICPHOS\" , vmax = \"p_PDC1_Vmax\" , k_half_substrate = \"p_PDC1_Kpyr\" , hill = \"p_PDC1_hill\" , ki = \"p_PDC1_Kpi\" ) v_ADH = Jax_ADH ( NAD = \"ICNAD\" , ETOH = \"ICETOH\" , NADH = \"ICNADH\" , ACE = \"ICACE\" , vmax = 'p_ADH_VmADH' , k_equilibrium = 'p_ADH_KeqADH' , km_substrate1 = 'p_ADH_KiADHNAD' , km_substrate2 = 'p_ADH_KmADHETOH' , km_product1 = 'p_ADH_KmADHACE' , km_product2 = 'p_ADH_KmADHNADH' , ki_substrate1 = 'p_ADH_KiADHNAD' , ki_substrate2 = 'p_ADH_KiADHETOH' , ki_product1 = 'p_ADH_KiADHACE' , ki_product2 = 'p_ADH_KiADHNADH' , exprs_cor = \"p_ADH_ExprsCor\" ) v_EtohT = Jax_Diffusion ( substrate = \"ICETOH\" , enzyme = \"f_ETOH_e\" , transport_coef = \"p_kETOHtransport\" ) Glycerophospholipid pathway # Glycerophospholipid (G3PDH, HOR2, GlycTransport) HOR2_inhibition_Pi = SimpleInhibitor ( k_I = \"p_HOR2_Kpi\" ) v_HOR2 = Jax_MM_Irrev_Uni_w_Modifiers ( substrate = \"ICG3P\" , vmax = \"p_HOR2_Vmax\" , km_substrate = \"p_HOR2_Kglyc3p\" , modifiers_list = [ \"ICPHOS\" ], modifiers = [ HOR2_inhibition_Pi ]) v_GlycT = Jax_Diffusion ( substrate = \"ICglyc\" , enzyme = \"f_GLYCEROL_e\" , transport_coef = \"p_GlycerolTransport\" ) v_G3PDH = Jax_MM_Rev_BiBi_w_Activation ( substrate1 = \"ICDHAP\" , substrate2 = \"ICNADH\" , product1 = \"ICG3P\" , product2 = \"ICNAD\" , modifiers = [ 'ICFBP' , 'ICATP' , 'ICADP' ], vmax = \"p_GPD1_Vmax\" , k_equilibrium = \"p_GPD1_Keq\" , km_substrate1 = \"p_GPD1_Kdhap\" , km_substrate2 = \"p_GPD1_Knadh\" , km_product1 = \"p_GPD1_Kglyc3p\" , km_product2 = \"p_GPD1_Knad\" , ka1 = \"p_GPD1_Kf16bp\" , ka2 = \"p_GPD1_Katp\" , ka3 = \"p_GPD1_Kadp\" ) Cofactor metabolism v_mitoNADH = Jax_MM ( substrate = \"ICNADH\" , vmax = \"p_mitoNADHVmax\" , km = \"p_mitoNADHKm\" ) #I think this can be replaced by Jax_MM_Irrev_Uni v_ATPmito = Jax_MM_Irrev_Bi ( \"ICADP\" , \"ICPHOS\" , vmax = \"p_mitoVmax\" , km_substrate1 = \"p_mitoADPKm\" , km_substrate2 = \"p_mitoPiKm\" ) v_ATPase = Jax_ATPase ( \"ICATP\" , \"ICADP\" , ATPase_ratio = \"p_ATPase_ratio\" ) v_ADK = Jax_MA_Rev_Bi ( substrate1 = \"ICADP\" , substrate2 = \"ICADP\" , product1 = \"ICATP\" , product2 = \"ICAMP\" , k_equilibrium = \"p_ADK1_Keq\" , k_fwd = \"p_ADK1_k\" ) v_VacPi = Jax_MA_Rev ( substrate = \"ICPHOS\" , k = \"p_vacuolePi_k\" , steady_state_substrate = \"p_vacuolePi_steadyStatePi\" ) v_AMD1 = Jax_Amd1 ( substrate = \"ICAMP\" , product = \"ICATP\" , modifier = \"ICPHOS\" , vmax = \"p_Amd1_Vmax\" , k50 = \"p_Amd1_K50\" , ki = \"p_Amd1_Kpi\" , k_atp = \"p_Amd1_Katp\" ) v_ADE1312 = Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Ade13_Ade12_k\" ) v_ISN1 = Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Isn1_k\" ) v_PNP1 = Jax_MA_Irrev ( substrate = \"ICINO\" , k_fwd = \"p_Pnp1_k\" ) v_HPT1 = Jax_MA_Irrev ( substrate = \"ICHYP\" , k_fwd = \"p_Hpt1_k\" ) Sink reactions are required due to the fact metabolism is only partially modeled. v_sinkG6P = Jax_MM_Sink ( substrate = 'ICG6P' , v_sink = 'poly_sinkG6P' , km_sink = 'km_sinkG6P' ) v_sinkF6P = Jax_MM_Sink ( substrate = 'ICF6P' , v_sink = 'poly_sinkF6P' , km_sink = 'km_sinkF6P' ) v_sinkGAP = Jax_MM_Sink ( substrate = \"ICGAP\" , v_sink = \"poly_sinkGAP\" , km_sink = \"km_sinkGAP\" ) vsink3PGA = Jax_MM_Sink ( substrate = 'IC3PG' , v_sink = 'poly_sinkP3G' , km_sink = 'km_sinkP3G' ) vsinkACE = Jax_MM_Sink ( substrate = \"ICACE\" , v_sink = \"poly_sinkACE\" , km_sink = \"km_sinkACE\" ) vsinkPYR = Jax_MM_Sink ( substrate = \"ICPYR\" , v_sink = \"poly_sinkPYR\" , km_sink = \"km_sinkPYR\" ) vsinkPEP = Jax_MM_Sink ( substrate = \"ICPEP\" , v_sink = \"poly_sinkPEP\" , km_sink = \"km_sinkPEP\" ) #reverse sign in stoichiometry Parameters After defining all reactions, we load the parameter set that fitted the data in [2] . The trained parameters are here given below, but can also be found in the results directory. TODO: make an online results directory that can be viewed. Custom ODE system We can now set up the ODE system, but note that it is not an ODE purely based on stoichiometry. The points in the ODEs where it is not purely stoichiometric are denoted with a ##!! class glycolysis (): def __init__ ( self , interpolate_dict : dict , met_names : list , dilution_rate : float ): self . interpolate_dict = interpolate_dict self . met_names = met_names self . dilution_rate = dilution_rate self . ECbiomass = self . interpolate_dict [ 'ECbiomass' ] . evaluate ( dilution_rate ) def __call__ ( self , t , y , args ): params = args y = dict ( zip ( self . met_names , y )) ##!! D = self . dilution_rate #dilution rate. In steady state D=mu y [ 'ECglucose' ] = self . interpolate_dict [ 'ECglucose' ] . evaluate ( t ) ##!! eval_dict = { ** y , ** params } #poly_sink parameters are defined based on a dilution rate dependency, which is an argument to the model eval_dict [ 'poly_sinkG6P' ] = jnp . abs ( 3.6854 * D ** 3 - 1.4119 * D ** 2 - 0.6312 * D - 0.0043 ) eval_dict [ 'poly_sinkF6P' ] = jnp . abs ( 519.3740 * D ** 6 - 447.7990 * D ** 5 + 97.2843 * D ** 4 + 8.0698 * D ** 3 - 4.4005 * D ** 2 + 0.6254 * D - 0.0078 ) eval_dict [ 'poly_sinkGAP' ] = jnp . abs ( 170.8447 * D ** 6 - 113.2975 * D ** 5 + 2.6494 * D ** 4 + 10.2461 * D ** 3 - 1.8002 * D ** 2 + 0.1988 * D + 0.0012 ) eval_dict [ 'poly_sinkP3G' ] = jnp . abs ( - 0.2381 * D ** 2 - 0.0210 * D - 0.0034 ) eval_dict [ 'poly_sinkPEP' ] = jnp . abs ( - 0.0637 * D ** 2 - 0.0617 * D - 0.0008 ) eval_dict [ 'poly_sinkPYR' ] = jnp . abs ( - 8.4853e+03 * D ** 6 + 9.4027e+03 * D ** 5 - 3.8027e+03 * D ** 4 + 700.5 * D ** 3 - 60.26 * D ** 2 + 0.711 * D - 0.0356 ) eval_dict [ 'poly_sinkACE' ] = jnp . abs ( 118.8562 * D ** 6 - 352.3943 * D ** 5 + 245.6092 * D ** 4 - 75.2550 * D ** 3 + 11.1153 * D ** 2 - 1.0379 * D + 0.0119 ) ## calculate the expression given the dilution rate and update parameters rate_vGLT = v_GLT ( eval_dict ) rate_vHXK = v_HXK ( eval_dict ) rate_vNTH1 = v_NTH1 ( eval_dict ) rate_vPGI = v_PGI ( eval_dict ) rate_vsinkG6P = v_sinkG6P ( eval_dict ) rate_vsinkF6P = v_sinkF6P ( eval_dict ) rate_vPGM1 = v_PGM1 ( eval_dict ) rate_vTPS1 = v_TPS1 ( eval_dict ) rate_vTPS2 = v_TPS2 ( eval_dict ) rate_vPFK = v_PFK ( eval_dict ) rate_vALD = v_ALD ( eval_dict ) rate_TPI1 = v_TPI1 ( eval_dict ) rate_GP3DH = v_G3PDH ( eval_dict ) rate_PGK = v_PGK ( eval_dict ) rate_vsinkGAP = v_sinkGAP ( eval_dict ) rate_GAPDH = v_GAPDH ( eval_dict ) rate_vsink3PGA = vsink3PGA ( eval_dict ) rate_HOR2 = v_HOR2 ( eval_dict ) rate_vGLycT = v_GlycT ( eval_dict ) rate_PGM = v_PGM ( eval_dict ) rate_ENO = v_ENO ( eval_dict ) rate_vsinkPEP = vsinkPEP ( eval_dict ) rate_PYK1 = v_PYK1 ( eval_dict ) rate_vsinkPYR = vsinkPYR ( eval_dict ) rate_vPDC = v_PDC ( eval_dict ) rate_ADH = v_ADH ( eval_dict ) rate_vsinkACE = vsinkACE ( eval_dict ) rate_ETOH_transport = v_EtohT ( eval_dict ) rate_vmitoNADH = v_mitoNADH ( eval_dict ) rate_ATPmito = v_ATPmito ( eval_dict ) rate_ATPase = v_ATPase ( eval_dict ) rate_ADK1 = v_ADK ( eval_dict ) rate_VacPi = v_VacPi ( eval_dict ) rate_AMD1 = v_AMD1 ( eval_dict ) rate_ADE1312 = v_ADE1312 ( eval_dict ) rate_ISN1 = v_ISN1 ( eval_dict ) rate_PNP1 = v_PNP1 ( eval_dict ) rate_HPT1 = v_HPT1 ( eval_dict ) dG1P =- rate_vPGM1 - params [ 'flux_ugp' ] dT6P =+ rate_vTPS1 - rate_vTPS2 dICTRE =+ rate_vTPS2 - rate_vNTH1 dICglci =+ rate_vGLT - rate_vHXK + 2 * rate_vNTH1 dICG6P =+ rate_vHXK - rate_vPGI - rate_vsinkG6P + rate_vPGM1 - rate_vTPS1 dICF6P =+ rate_vPGI + rate_vsinkF6P - rate_vPFK dICFBP =+ rate_vPFK - rate_vALD dICDHAP =+ rate_vALD - rate_TPI1 - rate_GP3DH dICG3P =+ rate_GP3DH - rate_HOR2 dICGlyc =+ rate_HOR2 - rate_vGLycT dICGAP =+ rate_vALD + rate_TPI1 - rate_GAPDH + rate_vsinkGAP dICBPG =+ rate_GAPDH - rate_PGK dIC3PG =+ rate_PGK - rate_vsink3PGA - rate_PGM dIC2PG =+ rate_PGM - rate_ENO dICPEP =+ rate_ENO - rate_vsinkPEP - rate_PYK1 dICPYR = + rate_PYK1 - rate_vPDC - rate_vsinkPYR dICACE = + rate_vPDC - rate_ADH - rate_vsinkACE dICETOH =+ rate_ADH - rate_ETOH_transport dICNAD =+ rate_GP3DH - rate_GAPDH + rate_ADH + rate_vmitoNADH dICNADH =- rate_GP3DH + rate_GAPDH - rate_ADH - rate_vmitoNADH dATP =+ rate_ADK1 - rate_vHXK - rate_ATPase - rate_vPFK + rate_PGK + rate_PYK1 - rate_vTPS1 + rate_ATPmito dADP =- 2 * rate_ADK1 + rate_vHXK + rate_ATPase + rate_vPFK - rate_PGK - rate_PYK1 + rate_vTPS2 - rate_ATPmito dAMP =+ rate_ADK1 - rate_AMD1 + rate_ADE1312 dPHOS =- rate_GAPDH + rate_ATPase + rate_HOR2 + 2 * rate_vTPS1 + rate_vTPS2 - rate_ATPmito + rate_ISN1 - rate_PNP1 + rate_VacPi + rate_vsinkG6P - rate_vsinkF6P + rate_vsink3PGA + rate_vsinkPEP - rate_vsinkGAP dIMP = rate_AMD1 - rate_ADE1312 + rate_HPT1 - rate_ISN1 dINO = rate_ISN1 - rate_PNP1 dHYP =+ rate_PNP1 - rate_HPT1 ##!! dECETOH =+ rate_ETOH_transport * self . ECbiomass * 0.002 - ( y [ 'ECETOH' ] / 3600 ) * self . dilution_rate #ethanol production dECglyc =+ rate_vGLycT * self . ECbiomass * 0.002 - ( y [ 'ECETOH' ] / 3600 ) * self . dilution_rate #glycerol ##!! return jnp . stack ([ dG1P , dT6P , dICTRE , dICglci , dICG6P , dICF6P , dICFBP , dICDHAP , dICG3P , dICGlyc , dICGAP , dICBPG , dIC3PG , dIC2PG , dICPEP , dICPYR , dICACE , dICETOH , dECETOH , dECglyc , dICNADH , dICNAD , dATP , dADP , dAMP , dPHOS , dIMP , dINO , dHYP ]) #,dICPEP,dICPYR,dICACE]) Parameterization For a script that parameterizes this model, we refer to the training scripts in scripts/experiments/ , or you can use the object-oriented training process as described in Training models References [1] Lao-Martil, D., Schmitz, J. P., Teusink, B., & van Riel, N. A. (2023). Elucidating yeast glycolytic dynamics at steady state growth and glucose pulses through kinetic metabolic modeling. Metabolic engineering, 77, 128-142. [2] Arxiv reference","title":"Custom models"},{"location":"glycolysis/#custom-ode-models","text":"Not all kinetic model can be drafted only from stoichiometry. There are many empirical laws that might influence reactions in the system of ODEs. Below, we present a reimplemented version [1] of a glycolysis model in Jax with a manually set up of ODEs.","title":"Custom ODE models"},{"location":"glycolysis/#glycolysis-model","text":"The model consists of 29 metabolites (ODEs), 38 reactions, with in total 141 parameters. The model can also be found in Github/models/manual_implementations and loaded from there.","title":"Glycolysis model"},{"location":"glycolysis/#rate-laws","text":"Start by loading the required kinetic mechanisms from jaxkineticmodel.kinetic_mechanisms.JaxKineticMechanisms import * from jaxkineticmodel.kinetic_mechanisms.JaxKineticMechanismsCustom import * from jaxkineticmodel.kinetic_mechanisms.JaxKineticModifiers import * Now, we define all reactions in the model. Note that names in substrates and products should match actual species names in the initial conditions. First, lower glycolysis. #upper glycolysis (GLT, HXK, PGI, PFK,ALD,TPI) v_GLT = Jax_Facilitated_Diffusion ( substrate_extracellular = 'ECglucose' , product_intracellular = 'ICglucose' , vmax = \"p_GLT_VmGLT\" , km_internal = 'p_GLT_KmGLTGLCi' , km_external = 'p_GLT_KmGLTGLCo' ) v_HXK = Jax_MM_Rev_BiBi_w_Inhibition ( substrate1 = 'ICATP' , substrate2 = \"ICglucose\" , product1 = \"ICADP\" , product2 = \"ICATP\" , modifier = \"ICT6P\" , vmax = \"p_HXK_Vmax\" , k_equilibrium = \"p_HXK1_Keq\" , km_substrate1 = \"p_HXK1_Katp\" , km_substrate2 = \"p_HXK1_Kglc\" , km_product1 = \"p_HXK1_Kadp\" , km_product2 = \"p_HXK1_Kg6p\" , ki_inhibitor = \"p_HXK1_Kt6p\" ) v_PGI = Jax_MM_Rev_UniUni ( substrate = 'ICG6P' , product = 'ICF6P' , vmax = 'p_PGI1_Vmax' , k_equilibrium = 'p_PGI1_Keq' , km_substrate = 'p_PGI1_Kg6p' , km_product = 'p_PGI1_Kf6p' ) v_PFK = Jax_PFK ( substrate1 = \"ICF6P\" , substrate2 = \"ICATP\" , product1 = \"ICFBP\" , modifier = \"ICAMP\" , vmax = \"p_PFK_Vmax\" , kr_F6P = \"p_PFK_Kf6p\" , kr_ATP = \"p_PFK_Katp\" , gr = \"p_PFK_gR\" , c_ATP = \"p_PFK_Catp\" , ci_ATP = \"p_PFK_Ciatp\" , ci_AMP = \"p_PFK_Camp\" , ci_F26BP = \"p_PFK_Cf26bp\" , ci_F16BP = \"p_PFK_Cf16bp\" , l = \"p_PFK_L\" , kATP = \"p_PFK_Kiatp\" , kAMP = \"p_PFK_Kamp\" , F26BP = \"p_PFK_F26BP\" , kF26BP = \"p_PFK_Kf26bp\" , kF16BP = \"p_PFK_Kf16bp\" ) v_ALD = Jax_MM_Rev_UniBi ( substrate = 'ICFBP' , product1 = 'ICGAP' , product2 = 'ICDHAP' , vmax = \"p_FBA1_Vmax\" , k_equilibrium = \"p_FBA1_Keq\" , km_substrate = \"p_FBA1_Kf16bp\" , km_product1 = \"p_FBA1_Kglyceral3p\" , km_product2 = \"p_FBA1_Kdhap\" ) v_TPI1 = Jax_MM_Rev_UniUni ( substrate = \"ICDHAP\" , product = \"ICGAP\" , vmax = \"p_TPI1_Vmax\" , k_equilibrium = \"p_TPI1_Keq\" , km_substrate = \"p_TPI1_Kdhap\" , km_product = \"p_TPI1_Kglyceral3p\" ) Trehalose cycle #trehalose cycle (NTH1, PGM1, TPS2, TPS1) v_NTH1 = Jax_MM_Irrev_Uni ( substrate = 'ICtreh' , vmax = 'p_NTH1_Vmax' , km_substrate = 'p_NTH1_Ktre' ) v_PGM1 = Jax_MM_Rev_UniUni ( substrate = 'ICG1P' , product = 'ICG6P' , vmax = 'p_PGM1_Vmax' , k_equilibrium = 'p_PGM1_Keq' , km_substrate = 'p_PGM1_Kg1p' , km_product = 'p_PGM1_Kg6p' ) #to do v_TPS1 for 2nd rate law # inhibitor_TPS1=SimpleInhibitor(k_I='p_TPS1_Kpi') activator_TPS1 = SimpleActivator ( k_A = \"p_TPS1_KmF6P\" ) v_TPS1 = Jax_MM_Irrev_Bi_w_Modifiers ( substrate1 = \"ICG6P\" , substrate2 = \"ICG1P\" , modifiers_list = [ 'ICF6P' ], vmax = \"p_TPS1_Vmax\" , km_substrate1 = \"p_TPS1_Kg6p\" , km_substrate2 = \"p_TPS1_Kudp_glc\" , modifiers = [ activator_TPS1 ]) # v_TPS1=Jax_MM_Irrev_Bi(substrate1=\"ICG6P\",substrate2=\"ICG1P\",vmax=\"p_TPS1_Vmax\",km_substrate1=\"p_TPS1_Kg6p\",km_substrate2=\"p_TPS1_Kudp_glc\") v_TPS2 = Jax_MM_Irrev_Bi_w_Inhibition ( substrate = \"ICT6P\" , product = \"ICPHOS\" , vmax = \"p_TPS2_Vmax\" , km_substrate1 = \"p_TPS2_Kt6p\" , ki = \"p_TPS2_Kpi\" ) Lower glycolysis # Lower glycolysis (GAPDH, PGK,PGM,ENO, PDC, ADH) v_GAPDH = Jax_MM_Ordered_Bi_Tri ( substrate1 = \"ICGAP\" , substrate2 = \"ICNAD\" , substrate3 = \"ICPHOS\" , product1 = \"ICBPG\" , product2 = \"ICNADH\" , vmax = \"p_GAPDH_Vmax\" , k_equilibrium = \"p_TDH1_Keq\" , km_substrate1 = \"p_TDH1_Kglyceral3p\" , km_substrate2 = \"p_TDH1_Knad\" , ki = \"p_TDH1_Kpi\" , km_product1 = \"p_TDH1_Kglycerate13bp\" , km_product2 = \"p_TDH1_Knadh\" ) #might exchange this mechanism by a BiBi mechanism, since modeling Phos is a bit too much v_PGK = Jax_MM_Rev_BiBi ( substrate1 = \"ICBPG\" , substrate2 = \"ICADP\" , product1 = \"IC3PG\" , product2 = \"ICATP\" , vmax = \"p_PGK_VmPGK\" , k_equilibrium = \"p_PGK_KeqPGK\" , km_substrate1 = \"p_PGK_KmPGKBPG\" , km_substrate2 = \"p_PGK_KmPGKADP\" , km_product1 = \"p_PGK_KmPGKP3G\" , km_product2 = \"p_PGK_KmPGKATP\" ) v_PGM = Jax_MM_Rev_UniUni ( substrate = \"IC3PG\" , product = \"IC2PG\" , vmax = \"p_PGM_Vm\" , k_equilibrium = \"p_PGM_Keq\" , km_substrate = \"p_PGM_K3pg\" , km_product = \"p_PGM_K2pg\" ) v_ENO = Jax_MM_Rev_UniUni ( substrate = \"IC2PG\" , product = \"ICPEP\" , vmax = \"p_ENO1_Vm\" , k_equilibrium = \"p_ENO1_Keq\" , km_substrate = \"p_ENO1_K2pg\" , km_product = \"p_ENO1_Kpep\" ) v_PYK1 = Jax_Hill_Irreversible_Bi_Activation ( substrate1 = \"ICPEP\" , substrate2 = \"ICADP\" , activator = \"ICFBP\" , product = \"ICATP\" , vmax = \"p_PYK1_Vm\" , hill = \"p_PYK1_hill\" , k_substrate1 = \"p_PYK1_Kpep\" , k_substrate2 = \"p_PYK1_Kadp\" , k_product = \"p_PYK1_Katp\" , k_activator = \"p_PYK1_Kf16bp\" , l = \"p_PYK1_L\" ) v_PDC = Jax_Hill_Irreversible_Inhibition ( substrate = \"ICPYR\" , inhibitor = \"ICPHOS\" , vmax = \"p_PDC1_Vmax\" , k_half_substrate = \"p_PDC1_Kpyr\" , hill = \"p_PDC1_hill\" , ki = \"p_PDC1_Kpi\" ) v_ADH = Jax_ADH ( NAD = \"ICNAD\" , ETOH = \"ICETOH\" , NADH = \"ICNADH\" , ACE = \"ICACE\" , vmax = 'p_ADH_VmADH' , k_equilibrium = 'p_ADH_KeqADH' , km_substrate1 = 'p_ADH_KiADHNAD' , km_substrate2 = 'p_ADH_KmADHETOH' , km_product1 = 'p_ADH_KmADHACE' , km_product2 = 'p_ADH_KmADHNADH' , ki_substrate1 = 'p_ADH_KiADHNAD' , ki_substrate2 = 'p_ADH_KiADHETOH' , ki_product1 = 'p_ADH_KiADHACE' , ki_product2 = 'p_ADH_KiADHNADH' , exprs_cor = \"p_ADH_ExprsCor\" ) v_EtohT = Jax_Diffusion ( substrate = \"ICETOH\" , enzyme = \"f_ETOH_e\" , transport_coef = \"p_kETOHtransport\" ) Glycerophospholipid pathway # Glycerophospholipid (G3PDH, HOR2, GlycTransport) HOR2_inhibition_Pi = SimpleInhibitor ( k_I = \"p_HOR2_Kpi\" ) v_HOR2 = Jax_MM_Irrev_Uni_w_Modifiers ( substrate = \"ICG3P\" , vmax = \"p_HOR2_Vmax\" , km_substrate = \"p_HOR2_Kglyc3p\" , modifiers_list = [ \"ICPHOS\" ], modifiers = [ HOR2_inhibition_Pi ]) v_GlycT = Jax_Diffusion ( substrate = \"ICglyc\" , enzyme = \"f_GLYCEROL_e\" , transport_coef = \"p_GlycerolTransport\" ) v_G3PDH = Jax_MM_Rev_BiBi_w_Activation ( substrate1 = \"ICDHAP\" , substrate2 = \"ICNADH\" , product1 = \"ICG3P\" , product2 = \"ICNAD\" , modifiers = [ 'ICFBP' , 'ICATP' , 'ICADP' ], vmax = \"p_GPD1_Vmax\" , k_equilibrium = \"p_GPD1_Keq\" , km_substrate1 = \"p_GPD1_Kdhap\" , km_substrate2 = \"p_GPD1_Knadh\" , km_product1 = \"p_GPD1_Kglyc3p\" , km_product2 = \"p_GPD1_Knad\" , ka1 = \"p_GPD1_Kf16bp\" , ka2 = \"p_GPD1_Katp\" , ka3 = \"p_GPD1_Kadp\" ) Cofactor metabolism v_mitoNADH = Jax_MM ( substrate = \"ICNADH\" , vmax = \"p_mitoNADHVmax\" , km = \"p_mitoNADHKm\" ) #I think this can be replaced by Jax_MM_Irrev_Uni v_ATPmito = Jax_MM_Irrev_Bi ( \"ICADP\" , \"ICPHOS\" , vmax = \"p_mitoVmax\" , km_substrate1 = \"p_mitoADPKm\" , km_substrate2 = \"p_mitoPiKm\" ) v_ATPase = Jax_ATPase ( \"ICATP\" , \"ICADP\" , ATPase_ratio = \"p_ATPase_ratio\" ) v_ADK = Jax_MA_Rev_Bi ( substrate1 = \"ICADP\" , substrate2 = \"ICADP\" , product1 = \"ICATP\" , product2 = \"ICAMP\" , k_equilibrium = \"p_ADK1_Keq\" , k_fwd = \"p_ADK1_k\" ) v_VacPi = Jax_MA_Rev ( substrate = \"ICPHOS\" , k = \"p_vacuolePi_k\" , steady_state_substrate = \"p_vacuolePi_steadyStatePi\" ) v_AMD1 = Jax_Amd1 ( substrate = \"ICAMP\" , product = \"ICATP\" , modifier = \"ICPHOS\" , vmax = \"p_Amd1_Vmax\" , k50 = \"p_Amd1_K50\" , ki = \"p_Amd1_Kpi\" , k_atp = \"p_Amd1_Katp\" ) v_ADE1312 = Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Ade13_Ade12_k\" ) v_ISN1 = Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Isn1_k\" ) v_PNP1 = Jax_MA_Irrev ( substrate = \"ICINO\" , k_fwd = \"p_Pnp1_k\" ) v_HPT1 = Jax_MA_Irrev ( substrate = \"ICHYP\" , k_fwd = \"p_Hpt1_k\" ) Sink reactions are required due to the fact metabolism is only partially modeled. v_sinkG6P = Jax_MM_Sink ( substrate = 'ICG6P' , v_sink = 'poly_sinkG6P' , km_sink = 'km_sinkG6P' ) v_sinkF6P = Jax_MM_Sink ( substrate = 'ICF6P' , v_sink = 'poly_sinkF6P' , km_sink = 'km_sinkF6P' ) v_sinkGAP = Jax_MM_Sink ( substrate = \"ICGAP\" , v_sink = \"poly_sinkGAP\" , km_sink = \"km_sinkGAP\" ) vsink3PGA = Jax_MM_Sink ( substrate = 'IC3PG' , v_sink = 'poly_sinkP3G' , km_sink = 'km_sinkP3G' ) vsinkACE = Jax_MM_Sink ( substrate = \"ICACE\" , v_sink = \"poly_sinkACE\" , km_sink = \"km_sinkACE\" ) vsinkPYR = Jax_MM_Sink ( substrate = \"ICPYR\" , v_sink = \"poly_sinkPYR\" , km_sink = \"km_sinkPYR\" ) vsinkPEP = Jax_MM_Sink ( substrate = \"ICPEP\" , v_sink = \"poly_sinkPEP\" , km_sink = \"km_sinkPEP\" ) #reverse sign in stoichiometry","title":"Rate laws"},{"location":"glycolysis/#parameters","text":"After defining all reactions, we load the parameter set that fitted the data in [2] . The trained parameters are here given below, but can also be found in the results directory. TODO: make an online results directory that can be viewed.","title":"Parameters"},{"location":"glycolysis/#custom-ode-system","text":"We can now set up the ODE system, but note that it is not an ODE purely based on stoichiometry. The points in the ODEs where it is not purely stoichiometric are denoted with a ##!! class glycolysis (): def __init__ ( self , interpolate_dict : dict , met_names : list , dilution_rate : float ): self . interpolate_dict = interpolate_dict self . met_names = met_names self . dilution_rate = dilution_rate self . ECbiomass = self . interpolate_dict [ 'ECbiomass' ] . evaluate ( dilution_rate ) def __call__ ( self , t , y , args ): params = args y = dict ( zip ( self . met_names , y )) ##!! D = self . dilution_rate #dilution rate. In steady state D=mu y [ 'ECglucose' ] = self . interpolate_dict [ 'ECglucose' ] . evaluate ( t ) ##!! eval_dict = { ** y , ** params } #poly_sink parameters are defined based on a dilution rate dependency, which is an argument to the model eval_dict [ 'poly_sinkG6P' ] = jnp . abs ( 3.6854 * D ** 3 - 1.4119 * D ** 2 - 0.6312 * D - 0.0043 ) eval_dict [ 'poly_sinkF6P' ] = jnp . abs ( 519.3740 * D ** 6 - 447.7990 * D ** 5 + 97.2843 * D ** 4 + 8.0698 * D ** 3 - 4.4005 * D ** 2 + 0.6254 * D - 0.0078 ) eval_dict [ 'poly_sinkGAP' ] = jnp . abs ( 170.8447 * D ** 6 - 113.2975 * D ** 5 + 2.6494 * D ** 4 + 10.2461 * D ** 3 - 1.8002 * D ** 2 + 0.1988 * D + 0.0012 ) eval_dict [ 'poly_sinkP3G' ] = jnp . abs ( - 0.2381 * D ** 2 - 0.0210 * D - 0.0034 ) eval_dict [ 'poly_sinkPEP' ] = jnp . abs ( - 0.0637 * D ** 2 - 0.0617 * D - 0.0008 ) eval_dict [ 'poly_sinkPYR' ] = jnp . abs ( - 8.4853e+03 * D ** 6 + 9.4027e+03 * D ** 5 - 3.8027e+03 * D ** 4 + 700.5 * D ** 3 - 60.26 * D ** 2 + 0.711 * D - 0.0356 ) eval_dict [ 'poly_sinkACE' ] = jnp . abs ( 118.8562 * D ** 6 - 352.3943 * D ** 5 + 245.6092 * D ** 4 - 75.2550 * D ** 3 + 11.1153 * D ** 2 - 1.0379 * D + 0.0119 ) ## calculate the expression given the dilution rate and update parameters rate_vGLT = v_GLT ( eval_dict ) rate_vHXK = v_HXK ( eval_dict ) rate_vNTH1 = v_NTH1 ( eval_dict ) rate_vPGI = v_PGI ( eval_dict ) rate_vsinkG6P = v_sinkG6P ( eval_dict ) rate_vsinkF6P = v_sinkF6P ( eval_dict ) rate_vPGM1 = v_PGM1 ( eval_dict ) rate_vTPS1 = v_TPS1 ( eval_dict ) rate_vTPS2 = v_TPS2 ( eval_dict ) rate_vPFK = v_PFK ( eval_dict ) rate_vALD = v_ALD ( eval_dict ) rate_TPI1 = v_TPI1 ( eval_dict ) rate_GP3DH = v_G3PDH ( eval_dict ) rate_PGK = v_PGK ( eval_dict ) rate_vsinkGAP = v_sinkGAP ( eval_dict ) rate_GAPDH = v_GAPDH ( eval_dict ) rate_vsink3PGA = vsink3PGA ( eval_dict ) rate_HOR2 = v_HOR2 ( eval_dict ) rate_vGLycT = v_GlycT ( eval_dict ) rate_PGM = v_PGM ( eval_dict ) rate_ENO = v_ENO ( eval_dict ) rate_vsinkPEP = vsinkPEP ( eval_dict ) rate_PYK1 = v_PYK1 ( eval_dict ) rate_vsinkPYR = vsinkPYR ( eval_dict ) rate_vPDC = v_PDC ( eval_dict ) rate_ADH = v_ADH ( eval_dict ) rate_vsinkACE = vsinkACE ( eval_dict ) rate_ETOH_transport = v_EtohT ( eval_dict ) rate_vmitoNADH = v_mitoNADH ( eval_dict ) rate_ATPmito = v_ATPmito ( eval_dict ) rate_ATPase = v_ATPase ( eval_dict ) rate_ADK1 = v_ADK ( eval_dict ) rate_VacPi = v_VacPi ( eval_dict ) rate_AMD1 = v_AMD1 ( eval_dict ) rate_ADE1312 = v_ADE1312 ( eval_dict ) rate_ISN1 = v_ISN1 ( eval_dict ) rate_PNP1 = v_PNP1 ( eval_dict ) rate_HPT1 = v_HPT1 ( eval_dict ) dG1P =- rate_vPGM1 - params [ 'flux_ugp' ] dT6P =+ rate_vTPS1 - rate_vTPS2 dICTRE =+ rate_vTPS2 - rate_vNTH1 dICglci =+ rate_vGLT - rate_vHXK + 2 * rate_vNTH1 dICG6P =+ rate_vHXK - rate_vPGI - rate_vsinkG6P + rate_vPGM1 - rate_vTPS1 dICF6P =+ rate_vPGI + rate_vsinkF6P - rate_vPFK dICFBP =+ rate_vPFK - rate_vALD dICDHAP =+ rate_vALD - rate_TPI1 - rate_GP3DH dICG3P =+ rate_GP3DH - rate_HOR2 dICGlyc =+ rate_HOR2 - rate_vGLycT dICGAP =+ rate_vALD + rate_TPI1 - rate_GAPDH + rate_vsinkGAP dICBPG =+ rate_GAPDH - rate_PGK dIC3PG =+ rate_PGK - rate_vsink3PGA - rate_PGM dIC2PG =+ rate_PGM - rate_ENO dICPEP =+ rate_ENO - rate_vsinkPEP - rate_PYK1 dICPYR = + rate_PYK1 - rate_vPDC - rate_vsinkPYR dICACE = + rate_vPDC - rate_ADH - rate_vsinkACE dICETOH =+ rate_ADH - rate_ETOH_transport dICNAD =+ rate_GP3DH - rate_GAPDH + rate_ADH + rate_vmitoNADH dICNADH =- rate_GP3DH + rate_GAPDH - rate_ADH - rate_vmitoNADH dATP =+ rate_ADK1 - rate_vHXK - rate_ATPase - rate_vPFK + rate_PGK + rate_PYK1 - rate_vTPS1 + rate_ATPmito dADP =- 2 * rate_ADK1 + rate_vHXK + rate_ATPase + rate_vPFK - rate_PGK - rate_PYK1 + rate_vTPS2 - rate_ATPmito dAMP =+ rate_ADK1 - rate_AMD1 + rate_ADE1312 dPHOS =- rate_GAPDH + rate_ATPase + rate_HOR2 + 2 * rate_vTPS1 + rate_vTPS2 - rate_ATPmito + rate_ISN1 - rate_PNP1 + rate_VacPi + rate_vsinkG6P - rate_vsinkF6P + rate_vsink3PGA + rate_vsinkPEP - rate_vsinkGAP dIMP = rate_AMD1 - rate_ADE1312 + rate_HPT1 - rate_ISN1 dINO = rate_ISN1 - rate_PNP1 dHYP =+ rate_PNP1 - rate_HPT1 ##!! dECETOH =+ rate_ETOH_transport * self . ECbiomass * 0.002 - ( y [ 'ECETOH' ] / 3600 ) * self . dilution_rate #ethanol production dECglyc =+ rate_vGLycT * self . ECbiomass * 0.002 - ( y [ 'ECETOH' ] / 3600 ) * self . dilution_rate #glycerol ##!! return jnp . stack ([ dG1P , dT6P , dICTRE , dICglci , dICG6P , dICF6P , dICFBP , dICDHAP , dICG3P , dICGlyc , dICGAP , dICBPG , dIC3PG , dIC2PG , dICPEP , dICPYR , dICACE , dICETOH , dECETOH , dECglyc , dICNADH , dICNAD , dATP , dADP , dAMP , dPHOS , dIMP , dINO , dHYP ]) #,dICPEP,dICPYR,dICACE])","title":"Custom ODE system"},{"location":"glycolysis/#parameterization","text":"For a script that parameterizes this model, we refer to the training scripts in scripts/experiments/ , or you can use the object-oriented training process as described in Training models","title":"Parameterization"},{"location":"glycolysis/#references","text":"[1] Lao-Martil, D., Schmitz, J. P., Teusink, B., & van Riel, N. A. (2023). Elucidating yeast glycolytic dynamics at steady state growth and glucose pulses through kinetic metabolic modeling. Metabolic engineering, 77, 128-142. [2] Arxiv reference","title":"References"},{"location":"simulated-DBTL/","text":"Simulated design-build-test-learn-cycles A simulation of metabolic engineering experiments DBTL cycles are widely used in the optimization of microorganisms for producing valuable compounds in a sustainable way. Despite the widespread use, many open questions exist when it comes to effectively using DBTL cycles. The reason for this is that due to the costly nature (in terms of time and money), effectively comparing design choices is never considered. It is for example highly unlikely that for the same optimization process, different sampling scenarios are compared, even though this might be valuable. An alternative cheap way to answer these types of questions is by simulating DBTL cycles [1] . Here, we show a reimplemented software of simulated-DBTL in Jax/Diffrax [2] . This allows users to test scenarios for their own lab settings. Figure 1: The design-build-test-learn cycle of iterative metabolic engineering, a widely adopted paradigm for strain engineering. Usage Import required functions from jaxkineticmodel.load_sbml.sbml_load import * from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import jax.numpy as jnp from jaxkineticmodel.utils import get_logger logger = get_logger ( __name__ ) from jaxkineticmodel.simulated_dbtl.dbtl import DesignBuildTestLearnCycle We first choose a kinetic model that we consider only as a black-box that outputs some target value. From this model scenarios are simulated that might be encountered in real metabolic engineering. At the heart of this implementation is the DesignBuildTestLearnCycle . This requires setting the initial parameters (the reference state), initial conditions, the timespan of process, and the target that we wish to simulate. # load model (Messiha et. al (2013)) filepath = ( \"../../models/sbml_models/working_models/Messiha2013.xml\" ) model = SBMLModel ( filepath ) # we retrieve parameters from the model global_params = get_global_parameters ( model . model ) params = { ** model . local_params , ** global_params } # timespan of model ts = jnp . linspace ( 0 , 6000 , 100 ) dbtl_cycle = DesignBuildTestLearnCycle ( model = model , parameters = params , initial_conditions = model . y0 , timespan = ts , target = [ 'PEP' ]) Design phase We now set up the combinatorial pathway optimization experiment. We define some parameter targets that we want to perturb. Then, each target gets some \"promoter\" values that perturb the parameters by multiplication. Then, we assign probabilities to each promoter-parameter values. If this function is empty, each promoter-parameter is equally probable. Finally, we generate the designs, for 40 samples and 5 chosen pro-parameter elements. # design phase parameter_target_names = [ 'lp.ADH.Kacald' , 'lp.ENO.kcat_ENO1' , 'lp.FBA.Kdhap' , 'lp.HXK.kcat_HXK1' , 'lp.PGK.kcat' , 'lp.HXT.Vmax' , 'lp.GND.Kp6g_GND1' ] parameter_perturbation_value = [[ 0.2 , 0.5 , 1 , 1.5 , 2 ], # 'lp.ADH.Kacald' [ 1.2 , 1.5 , 1.8 ], # 'lp.ENO.kcat_ENO1' [ 1.1 , 1.6 , 1.3 ], # 'lp.FBA.Kdhap' [ 0.6 , 1.1 , 2 , 3 ], # 'lp.HXK.kcat_HXK1' [ 1 , 2 , 3 ], # 'lp.PGK.kcat' [ 0.5 , 1 , 1.5 ], # 'lp.HXT.Vmax' [ 2 , 3 , 4 ]] # 'lp.GND.Kp6g_GND1' dbtl_cycle . design_establish_library_elements ( parameter_target_names , parameter_perturbation_value ) dbtl_cycle . design_assign_probabilities () # The replacement is false means that each pro-parameter # pair can only be chosen once from the list per strain design strain_designs = dbtl_cycle . design_generate_strains ( elements = 6 , samples = 40 , replacement = False ) Build/Test phase In the build phase we simulate all the designs and add a noise model to the outcomes for the target. The first simulation will take quite long, but after that it is compiled. If you do not run the class DesignBuildTestLearnCycle again, the simulations remain fast. The values that are taken in the dataset is the average of the last 10 datapoints of the target state variable. # build phase values = dbtl_cycle . build_simulate_strains ( strain_designs , plot = False ) # test phase noised_values = dbtl_cycle . test_add_noise ( values , 0.1 , noisetype = 'heteroschedastic' ) data = dbtl_cycle . test_format_dataset ( strain_designs = strain_designs , production_values = noised_values , reference_parameters = dbtl_cycle . parameters ) Learn phase From here, the produced data can be used to compare whatever hyperparameter of the DBTL cycle you are interested: the performance of ML models, DoE v.s. Random sampling, etc.. As an example, we train an XGBoost model on the set of generated datapoints, as well as a quick validation on newly generated strain designs. # learn phase xgbparameters = { 'tree_method' : 'auto' , 'reg_lambda' : 1 , 'max_depth' : 2 , \"disable_default_eval_metric\" : 0 } alternative_params = { 'num_boost_round' : 10 , 'early_stopping_rounds' : 40 } bst , r2_scores = dbtl_cycle . learn_train_model ( data = data , target = \"PEP\" , model_type = \"XGBoost\" , args = ( xgbparameters , alternative_params ), test_size = 0.20 ) dbtl_cycle . learn_validate_model ( samples = 12 , elements = 12 , target = 'PEP' , plotting = True ) Figure 2: Model performance (true versups predicted values). References [1] van Lent, P., Schmitz, J., & Abeel, T. (2023). Simulated design\u2013build\u2013test\u2013learn cycles for consistent comparison of machine learning methods in metabolic engineering. ACS Synthetic Biology, 12(9), 2588-2599. [2] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435.","title":"Simulated-DBTL"},{"location":"simulated-DBTL/#simulated-design-build-test-learn-cycles","text":"","title":"Simulated design-build-test-learn-cycles"},{"location":"simulated-DBTL/#a-simulation-of-metabolic-engineering-experiments","text":"DBTL cycles are widely used in the optimization of microorganisms for producing valuable compounds in a sustainable way. Despite the widespread use, many open questions exist when it comes to effectively using DBTL cycles. The reason for this is that due to the costly nature (in terms of time and money), effectively comparing design choices is never considered. It is for example highly unlikely that for the same optimization process, different sampling scenarios are compared, even though this might be valuable. An alternative cheap way to answer these types of questions is by simulating DBTL cycles [1] . Here, we show a reimplemented software of simulated-DBTL in Jax/Diffrax [2] . This allows users to test scenarios for their own lab settings. Figure 1: The design-build-test-learn cycle of iterative metabolic engineering, a widely adopted paradigm for strain engineering.","title":"A simulation of metabolic engineering experiments"},{"location":"simulated-DBTL/#usage","text":"Import required functions from jaxkineticmodel.load_sbml.sbml_load import * from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import jax.numpy as jnp from jaxkineticmodel.utils import get_logger logger = get_logger ( __name__ ) from jaxkineticmodel.simulated_dbtl.dbtl import DesignBuildTestLearnCycle We first choose a kinetic model that we consider only as a black-box that outputs some target value. From this model scenarios are simulated that might be encountered in real metabolic engineering. At the heart of this implementation is the DesignBuildTestLearnCycle . This requires setting the initial parameters (the reference state), initial conditions, the timespan of process, and the target that we wish to simulate. # load model (Messiha et. al (2013)) filepath = ( \"../../models/sbml_models/working_models/Messiha2013.xml\" ) model = SBMLModel ( filepath ) # we retrieve parameters from the model global_params = get_global_parameters ( model . model ) params = { ** model . local_params , ** global_params } # timespan of model ts = jnp . linspace ( 0 , 6000 , 100 ) dbtl_cycle = DesignBuildTestLearnCycle ( model = model , parameters = params , initial_conditions = model . y0 , timespan = ts , target = [ 'PEP' ])","title":"Usage"},{"location":"simulated-DBTL/#design-phase","text":"We now set up the combinatorial pathway optimization experiment. We define some parameter targets that we want to perturb. Then, each target gets some \"promoter\" values that perturb the parameters by multiplication. Then, we assign probabilities to each promoter-parameter values. If this function is empty, each promoter-parameter is equally probable. Finally, we generate the designs, for 40 samples and 5 chosen pro-parameter elements. # design phase parameter_target_names = [ 'lp.ADH.Kacald' , 'lp.ENO.kcat_ENO1' , 'lp.FBA.Kdhap' , 'lp.HXK.kcat_HXK1' , 'lp.PGK.kcat' , 'lp.HXT.Vmax' , 'lp.GND.Kp6g_GND1' ] parameter_perturbation_value = [[ 0.2 , 0.5 , 1 , 1.5 , 2 ], # 'lp.ADH.Kacald' [ 1.2 , 1.5 , 1.8 ], # 'lp.ENO.kcat_ENO1' [ 1.1 , 1.6 , 1.3 ], # 'lp.FBA.Kdhap' [ 0.6 , 1.1 , 2 , 3 ], # 'lp.HXK.kcat_HXK1' [ 1 , 2 , 3 ], # 'lp.PGK.kcat' [ 0.5 , 1 , 1.5 ], # 'lp.HXT.Vmax' [ 2 , 3 , 4 ]] # 'lp.GND.Kp6g_GND1' dbtl_cycle . design_establish_library_elements ( parameter_target_names , parameter_perturbation_value ) dbtl_cycle . design_assign_probabilities () # The replacement is false means that each pro-parameter # pair can only be chosen once from the list per strain design strain_designs = dbtl_cycle . design_generate_strains ( elements = 6 , samples = 40 , replacement = False )","title":"Design phase"},{"location":"simulated-DBTL/#buildtest-phase","text":"In the build phase we simulate all the designs and add a noise model to the outcomes for the target. The first simulation will take quite long, but after that it is compiled. If you do not run the class DesignBuildTestLearnCycle again, the simulations remain fast. The values that are taken in the dataset is the average of the last 10 datapoints of the target state variable. # build phase values = dbtl_cycle . build_simulate_strains ( strain_designs , plot = False ) # test phase noised_values = dbtl_cycle . test_add_noise ( values , 0.1 , noisetype = 'heteroschedastic' ) data = dbtl_cycle . test_format_dataset ( strain_designs = strain_designs , production_values = noised_values , reference_parameters = dbtl_cycle . parameters )","title":"Build/Test phase"},{"location":"simulated-DBTL/#learn-phase","text":"From here, the produced data can be used to compare whatever hyperparameter of the DBTL cycle you are interested: the performance of ML models, DoE v.s. Random sampling, etc.. As an example, we train an XGBoost model on the set of generated datapoints, as well as a quick validation on newly generated strain designs. # learn phase xgbparameters = { 'tree_method' : 'auto' , 'reg_lambda' : 1 , 'max_depth' : 2 , \"disable_default_eval_metric\" : 0 } alternative_params = { 'num_boost_round' : 10 , 'early_stopping_rounds' : 40 } bst , r2_scores = dbtl_cycle . learn_train_model ( data = data , target = \"PEP\" , model_type = \"XGBoost\" , args = ( xgbparameters , alternative_params ), test_size = 0.20 ) dbtl_cycle . learn_validate_model ( samples = 12 , elements = 12 , target = 'PEP' , plotting = True ) Figure 2: Model performance (true versups predicted values).","title":"Learn phase"},{"location":"simulated-DBTL/#references","text":"[1] van Lent, P., Schmitz, J., & Abeel, T. (2023). Simulated design\u2013build\u2013test\u2013learn cycles for consistent comparison of machine learning methods in metabolic engineering. ACS Synthetic Biology, 12(9), 2588-2599. [2] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435.","title":"References"},{"location":"training_models/","text":"Training metabolic kinetic models Here, we showcase an parameter optimization process with simulated data [1] . The Trainer object The Trainer object requires a few inputs. First, it requires a SBMLModel or a NeuralODEBuild object to be used. The second input is a datasets to fit on. Here, we show the fitting of a previously reported Serine Biosynthesis model [1] . Setting up the trainer object + training First, we load the necessary functions from jaxkineticmodel.parameter_estimation.training import Trainer from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import numpy as np import matplotlib.pyplot as plt import pandas as pd Then, we load the model, data and initialize the trainer object. #load model model_name = \"Smallbone2013_SerineBiosynthesis\" filepath = \"../../models/sbml_models/working_models/\" + model_name + \".xml\" model = SBMLModel ( filepath ) #load data dataset = pd . read_csv ( \"../../datasets/Smallbone2013 - Serine biosynthesis/Smallbone2013 - Serine biosynthesis_dataset.csv\" , index_col = 0 ) #initialize the trainer object. The required inputs are model and data. We will do 300 iterations of gradient descent trainer = Trainer ( model = model , data = dataset , n_iter = 300 ) We next perform a latin hypercube sampling for a certain initial guess, with lower and upperbound defined with respect to these values. We want five initializations (normally this should be higher). base_parameters = dict ( zip ( trainer . parameters , np . ones ( len ( trainer . parameters )))) parameter_sets = trainer . latinhypercube_sampling ( base_parameters , lower_bound = 1 / 10 , upper_bound = 10 , N = 5 ) To initiate training, you simply call the function Trainer.train() optimized_parameters , loss_per_iteration , global_norms = trainer . train () #plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): ax . plot ( loss_per_iteration [ i ]) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () Figure 1: Loss per iteration for five initializations. Additional rounds Suppose the fit is not to your liking, or we first want to do a pre-optimization of a large set of parameters and then filter promising sets, one can continue the optimization by re-running the trainer object with the set of optimized parameters. params_round1 = pd . DataFrame ( optimized_parameters ) . T trainer . parameter_sets = params_round1 trainer . n_iter = 500 optimized_parameters2 , loss_per_iteration2 , global_norms2 = trainer . train () #plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): plt . plot ( np . concatenate (( np . array ( loss_per_iteration [ i ]), loss_per_iteration2 [ i ]))) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () Figure 2: Loss per iteration for five initializations, extended with 500 rounds of gradient descent. References [1] Smallbone, K., & Stanford, N. J. (2013). Kinetic modeling of metabolic pathways: Application to serine biosynthesis. Systems Metabolic Engineering: Methods and Protocols, 113-121.","title":"Training models"},{"location":"training_models/#training-metabolic-kinetic-models","text":"Here, we showcase an parameter optimization process with simulated data [1] .","title":"Training metabolic kinetic models"},{"location":"training_models/#the-trainer-object","text":"The Trainer object requires a few inputs. First, it requires a SBMLModel or a NeuralODEBuild object to be used. The second input is a datasets to fit on. Here, we show the fitting of a previously reported Serine Biosynthesis model [1] .","title":"The Trainer object"},{"location":"training_models/#setting-up-the-trainer-object-training","text":"First, we load the necessary functions from jaxkineticmodel.parameter_estimation.training import Trainer from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import numpy as np import matplotlib.pyplot as plt import pandas as pd Then, we load the model, data and initialize the trainer object. #load model model_name = \"Smallbone2013_SerineBiosynthesis\" filepath = \"../../models/sbml_models/working_models/\" + model_name + \".xml\" model = SBMLModel ( filepath ) #load data dataset = pd . read_csv ( \"../../datasets/Smallbone2013 - Serine biosynthesis/Smallbone2013 - Serine biosynthesis_dataset.csv\" , index_col = 0 ) #initialize the trainer object. The required inputs are model and data. We will do 300 iterations of gradient descent trainer = Trainer ( model = model , data = dataset , n_iter = 300 ) We next perform a latin hypercube sampling for a certain initial guess, with lower and upperbound defined with respect to these values. We want five initializations (normally this should be higher). base_parameters = dict ( zip ( trainer . parameters , np . ones ( len ( trainer . parameters )))) parameter_sets = trainer . latinhypercube_sampling ( base_parameters , lower_bound = 1 / 10 , upper_bound = 10 , N = 5 ) To initiate training, you simply call the function Trainer.train() optimized_parameters , loss_per_iteration , global_norms = trainer . train () #plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): ax . plot ( loss_per_iteration [ i ]) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () Figure 1: Loss per iteration for five initializations.","title":"Setting up the trainer object + training"},{"location":"training_models/#additional-rounds","text":"Suppose the fit is not to your liking, or we first want to do a pre-optimization of a large set of parameters and then filter promising sets, one can continue the optimization by re-running the trainer object with the set of optimized parameters. params_round1 = pd . DataFrame ( optimized_parameters ) . T trainer . parameter_sets = params_round1 trainer . n_iter = 500 optimized_parameters2 , loss_per_iteration2 , global_norms2 = trainer . train () #plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): plt . plot ( np . concatenate (( np . array ( loss_per_iteration [ i ]), loss_per_iteration2 [ i ]))) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () Figure 2: Loss per iteration for five initializations, extended with 500 rounds of gradient descent.","title":"Additional rounds"},{"location":"training_models/#references","text":"[1] Smallbone, K., & Stanford, N. J. (2013). Kinetic modeling of metabolic pathways: Application to serine biosynthesis. Systems Metabolic Engineering: Methods and Protocols, 113-121.","title":"References"}]}