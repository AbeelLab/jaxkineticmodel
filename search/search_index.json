{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Summary Introduction Installation Minimal simulation example Reference","title":"Home"},{"location":"#summary","text":"","title":"Summary"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#installation","text":"","title":"Installation"},{"location":"#minimal-simulation-example","text":"","title":"Minimal simulation example"},{"location":"#reference","text":"","title":"Reference"},{"location":"SBML/","text":"Loading SBML models SBML loader and simulation SBML models can be loaded and simulated as follows. import matplotlib.pyplot as plt import os import sys , os from source.load_sbml.sbml_load import * from source.load_sbml.sbml_model import SBMLModel filepath = ( \"models/sbml_models/working_models/simple_sbml.xml\" ) # load model from file_path model = SBMLModel ( filepath ) S = model . _get_stoichiometric_matrix () JaxKmodel = model . get_kinetic_model () ts = jnp . linspace ( 0 , 100 , 2000 ) # parameters in sbml can be either global or local parameters. For gradient descent purposes we want all of them global. params = get_global_parameters ( model . model ) params = { ** model . local_params , ** params } #simulate given the initial conditions defined in the sbml ys = JaxKmodel ( ts = ts , y0 = model . y0 , params = params ) ys = pd . DataFrame ( ys , columns = S . index ) Percentage of similar models Status report on a large collection of SBML models loaded from biomodels and from a benchmark collection [1] . Discrepancies are models where we compared the output from JaxKineticModel to a simulation using tellurium [2] , a popular tool in systems biology. Discrepancies could be there because of numerical differences in the results, or potentially a missing feature in our current implementation (certain event rules are not implemented yet.) Category Number of working models Models working 31 Failing models 2 Discrepancies 5 References [1] Hass, H., Loos, C., Raimundez-Alvarez, E., Timmer, J., Hasenauer, J., & Kreutz, C. (2019). Benchmark problems for dynamic modeling of intracellular processes. Bioinformatics, 35(17), 3073-3082. [2] Choi, K., Medley, J. K., K\u00f6nig, M., Stocking, K., Smith, L., Gu, S., & Sauro, H. M. (2018). Tellurium: an extensible python-based modeling environment for systems and synthetic biology. Biosystems, 171, 74-79.","title":"SBML models"},{"location":"SBML/#loading-sbml-models","text":"","title":"Loading SBML models"},{"location":"SBML/#sbml-loader-and-simulation","text":"SBML models can be loaded and simulated as follows. import matplotlib.pyplot as plt import os import sys , os from source.load_sbml.sbml_load import * from source.load_sbml.sbml_model import SBMLModel filepath = ( \"models/sbml_models/working_models/simple_sbml.xml\" ) # load model from file_path model = SBMLModel ( filepath ) S = model . _get_stoichiometric_matrix () JaxKmodel = model . get_kinetic_model () ts = jnp . linspace ( 0 , 100 , 2000 ) # parameters in sbml can be either global or local parameters. For gradient descent purposes we want all of them global. params = get_global_parameters ( model . model ) params = { ** model . local_params , ** params } #simulate given the initial conditions defined in the sbml ys = JaxKmodel ( ts = ts , y0 = model . y0 , params = params ) ys = pd . DataFrame ( ys , columns = S . index )","title":"SBML loader and simulation"},{"location":"SBML/#percentage-of-similar-models","text":"Status report on a large collection of SBML models loaded from biomodels and from a benchmark collection [1] . Discrepancies are models where we compared the output from JaxKineticModel to a simulation using tellurium [2] , a popular tool in systems biology. Discrepancies could be there because of numerical differences in the results, or potentially a missing feature in our current implementation (certain event rules are not implemented yet.) Category Number of working models Models working 31 Failing models 2 Discrepancies 5","title":"Percentage of similar models"},{"location":"SBML/#references","text":"[1] Hass, H., Loos, C., Raimundez-Alvarez, E., Timmer, J., Hasenauer, J., & Kreutz, C. (2019). Benchmark problems for dynamic modeling of intracellular processes. Bioinformatics, 35(17), 3073-3082. [2] Choi, K., Medley, J. K., K\u00f6nig, M., Stocking, K., Smith, L., Gu, S., & Sauro, H. M. (2018). Tellurium: an extensible python-based modeling environment for systems and synthetic biology. Biosystems, 171, 74-79.","title":"References"},{"location":"building_models/","text":"Building models Metabolic kinetic modelling The time evolution of metabolic states are often described by a set of Ordinary Differential Equations (ODEs) $$\\frac{dm(t)}{dt}=S\\cdot v(t,m(t),\\theta)$$ \\(S\\) is the stoichiometric matrix that describes the mass balances of a metabolic system. The fluxes \\(v\\) are described by reaction mechanisms, typically of some form like Michaelis-Menten or Hill equations. These mechanisms are parameterized by \\(\\theta\\). By providing the initial values of the metabolic states, the ODEs can be solved using a numerical solver $$m(T)=m(0)+\\int_0^T S\\cdot v(t,m(t),\\theta)dt$$ We will describe below how you can build your own models that are compatible with Jax/Diffrax [1] . The Reaction object A reaction-centric approach Models can be built in a reaction-centric manner. The Reaction object requires setting five inputs: name of the reaction, stoichiometry of the reaction, compartments of the species involved, and it's mechanism. from source.kinetic_mechanisms import JaxKineticMechanisms as jm from source.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import jax import numpy as np import diffrax import matplotlib.pyplot as plt import pandas as pd ReactionA = jkm . Reaction ( name = \"ReactionA\" , species = [ 'A' , 'B' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"A\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) The mechanism is another class that describes the flux function, which depends on metabolite states and parameters. Parameters are pointed towards with unique symbols. The reaction object is implemented in a way that own-implemented flux functions can be used. We have also implemented a set of general flux functions that are often used in systems biology. Table of implemented mechanisms Type of Reaction Name (in JAX class) Number of Parameters A \u2192 B Jax_MM_Irrev_Uni 2 A \u2192 B Jax_MM_Irrev_Uni_w_modifiers 2 + modifiers A \u2194 B Jax_MM_Rev_UniUni 4 A \u2192 Jax_MM_Sink 2 A \u2192 Jax_MA_Irrev 1 A \u21d2 Jax_Facilitated_Diffusion 3 A \u21d2 Jax_Diffusion 2 A + B \u2192 C Jax_MM_Irrev_Bi 3 Jax_MM_Irrev_Bi_w_Inhibition 3 Jax_MM_Irrev_Bi_w_modifiers 3 + modifiers A + B \u2194 C + D Jax_MM_Rev_BiBi 6 Jax_MM_Rev_BiBi_w_Inhibition 7 Jax_MM_Rev_BiBi_w_Activation 9 A + B \u2194 C + D Jax_MA_Rev_Bi 2 A \u2194 B + C Jax_MM_Rev_UniBi 5 A + B \u2192 C + D + E Jax_MM_Ordered_BiTri 7 A + B \u2192 C + D Jax_ADH 15 A \u2192 B + C Jax_Hill_Bi_Irreversible_Activation 7 A \u2192 B + C Jax_Hill_Irreversible_Inhibition 7 Building simple models A simple metabolic network example Here, we show an example of how to build kinetic models using the reaction objects described above. We model the following network: Three metabolic fluxes need to be modelled #Add reactions v1 to v3 v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) v2 = jkm . Reaction ( name = \"v2\" , species = [ 'm2' , 'm3' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"B_Vmax\" , km_substrate = \"B_Km\" ), ) v3 = jkm . Reaction ( name = \"v3\" , species = [ 'm2' , 'm4' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"C_Vmax\" , km_substrate = \"C_Km\" ), ) reactions = [ v1 , v2 , v3 ] compartment_values = { 'c' : 1 } # initialized the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODE ( kmodel ) print ( kmodel . stoichiometric_matrix ) The stoichiometric matrix is automatically constructed from the reactions. v1 v2 v3 m1 -1.0 0.0 0.0 m2 1.0 -1.0 -1.0 m3 0.0 1.0 0.0 m4 0.0 0.0 1.0 One can first jax.jit the model [2] and solve the ODEs using the diffrax package [1] , which contains many nice numerical solvers. #define the time interval, and the initial conditions ts = jnp . linspace ( 0 , 10 , 1000 ) y0 = jnp . array ([ 2 , 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () On jit-compiling kinetic models When you simulated a jit-compiled kinetic model for a certain time-range (e.g., jnp.linspace(0,10,1000) and you want to elongate this, it is best to not change the number of timepoints (e.g, jnp.linspace(0,1000,1000) . Otherwise, the kinetic models needs to be recompiled. Boundary conditions Boundary conditions can be either constant or not constant. Both are implemented as a BoundaryCondition class Constant boundary conditions Suppose for the system above, we want to make metabolite \\(m_1\\) a constant boundary condition. We can redefine the species by replacing it with a value kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( 2 )) print ( kmodel . stoichiometric_matrix ) #recompile and simulate kmodel_sim = jkm . NeuralODE ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) #plot fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () Non-constant boundary conditions For non-constant boundary conditions, you can use the BoundaryCondition class as before. You can use for example the interpolation abstract classes from Diffrax . For analytic expression dependent on time t, these can be done as follows: # initialized the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '0.1*sin(t)' )) print ( kmodel . stoichiometric_matrix ) kmodel_sim = jkm . NeuralODE ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () Saving models To do (or remove) References [1] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435. [2] Bradbury, J., Frostig, R., Hawkins, P., Johnson, M. J., Leary, C., Maclaurin, D., ... & Zhang, Q. (2018). JAX: composable transformations of Python+ NumPy programs.","title":"Building models"},{"location":"building_models/#building-models","text":"","title":"Building models"},{"location":"building_models/#metabolic-kinetic-modelling","text":"The time evolution of metabolic states are often described by a set of Ordinary Differential Equations (ODEs) $$\\frac{dm(t)}{dt}=S\\cdot v(t,m(t),\\theta)$$ \\(S\\) is the stoichiometric matrix that describes the mass balances of a metabolic system. The fluxes \\(v\\) are described by reaction mechanisms, typically of some form like Michaelis-Menten or Hill equations. These mechanisms are parameterized by \\(\\theta\\). By providing the initial values of the metabolic states, the ODEs can be solved using a numerical solver $$m(T)=m(0)+\\int_0^T S\\cdot v(t,m(t),\\theta)dt$$ We will describe below how you can build your own models that are compatible with Jax/Diffrax [1] .","title":"Metabolic kinetic modelling"},{"location":"building_models/#the-reaction-object","text":"","title":"The Reaction object"},{"location":"building_models/#a-reaction-centric-approach","text":"Models can be built in a reaction-centric manner. The Reaction object requires setting five inputs: name of the reaction, stoichiometry of the reaction, compartments of the species involved, and it's mechanism. from source.kinetic_mechanisms import JaxKineticMechanisms as jm from source.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import jax import numpy as np import diffrax import matplotlib.pyplot as plt import pandas as pd ReactionA = jkm . Reaction ( name = \"ReactionA\" , species = [ 'A' , 'B' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"A\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) The mechanism is another class that describes the flux function, which depends on metabolite states and parameters. Parameters are pointed towards with unique symbols. The reaction object is implemented in a way that own-implemented flux functions can be used. We have also implemented a set of general flux functions that are often used in systems biology.","title":"A reaction-centric approach"},{"location":"building_models/#table-of-implemented-mechanisms","text":"Type of Reaction Name (in JAX class) Number of Parameters A \u2192 B Jax_MM_Irrev_Uni 2 A \u2192 B Jax_MM_Irrev_Uni_w_modifiers 2 + modifiers A \u2194 B Jax_MM_Rev_UniUni 4 A \u2192 Jax_MM_Sink 2 A \u2192 Jax_MA_Irrev 1 A \u21d2 Jax_Facilitated_Diffusion 3 A \u21d2 Jax_Diffusion 2 A + B \u2192 C Jax_MM_Irrev_Bi 3 Jax_MM_Irrev_Bi_w_Inhibition 3 Jax_MM_Irrev_Bi_w_modifiers 3 + modifiers A + B \u2194 C + D Jax_MM_Rev_BiBi 6 Jax_MM_Rev_BiBi_w_Inhibition 7 Jax_MM_Rev_BiBi_w_Activation 9 A + B \u2194 C + D Jax_MA_Rev_Bi 2 A \u2194 B + C Jax_MM_Rev_UniBi 5 A + B \u2192 C + D + E Jax_MM_Ordered_BiTri 7 A + B \u2192 C + D Jax_ADH 15 A \u2192 B + C Jax_Hill_Bi_Irreversible_Activation 7 A \u2192 B + C Jax_Hill_Irreversible_Inhibition 7","title":"Table of implemented mechanisms"},{"location":"building_models/#building-simple-models","text":"","title":"Building simple models"},{"location":"building_models/#a-simple-metabolic-network-example","text":"Here, we show an example of how to build kinetic models using the reaction objects described above. We model the following network: Three metabolic fluxes need to be modelled #Add reactions v1 to v3 v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) v2 = jkm . Reaction ( name = \"v2\" , species = [ 'm2' , 'm3' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"B_Vmax\" , km_substrate = \"B_Km\" ), ) v3 = jkm . Reaction ( name = \"v3\" , species = [ 'm2' , 'm4' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"C_Vmax\" , km_substrate = \"C_Km\" ), ) reactions = [ v1 , v2 , v3 ] compartment_values = { 'c' : 1 } # initialized the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODE ( kmodel ) print ( kmodel . stoichiometric_matrix ) The stoichiometric matrix is automatically constructed from the reactions. v1 v2 v3 m1 -1.0 0.0 0.0 m2 1.0 -1.0 -1.0 m3 0.0 1.0 0.0 m4 0.0 0.0 1.0 One can first jax.jit the model [2] and solve the ODEs using the diffrax package [1] , which contains many nice numerical solvers. #define the time interval, and the initial conditions ts = jnp . linspace ( 0 , 10 , 1000 ) y0 = jnp . array ([ 2 , 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend ()","title":"A simple metabolic network example"},{"location":"building_models/#on-jit-compiling-kinetic-models","text":"When you simulated a jit-compiled kinetic model for a certain time-range (e.g., jnp.linspace(0,10,1000) and you want to elongate this, it is best to not change the number of timepoints (e.g, jnp.linspace(0,1000,1000) . Otherwise, the kinetic models needs to be recompiled.","title":"On jit-compiling kinetic models"},{"location":"building_models/#boundary-conditions","text":"Boundary conditions can be either constant or not constant. Both are implemented as a BoundaryCondition class","title":"Boundary conditions"},{"location":"building_models/#constant-boundary-conditions","text":"Suppose for the system above, we want to make metabolite \\(m_1\\) a constant boundary condition. We can redefine the species by replacing it with a value kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( 2 )) print ( kmodel . stoichiometric_matrix ) #recompile and simulate kmodel_sim = jkm . NeuralODE ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) #plot fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend ()","title":"Constant boundary conditions"},{"location":"building_models/#non-constant-boundary-conditions","text":"For non-constant boundary conditions, you can use the BoundaryCondition class as before. You can use for example the interpolation abstract classes from Diffrax . For analytic expression dependent on time t, these can be done as follows: # initialized the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModel_Build ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '0.1*sin(t)' )) print ( kmodel . stoichiometric_matrix ) kmodel_sim = jkm . NeuralODE ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend ()","title":"Non-constant boundary conditions"},{"location":"building_models/#saving-models","text":"To do (or remove)","title":"Saving models"},{"location":"building_models/#references","text":"[1] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435. [2] Bradbury, J., Frostig, R., Hawkins, P., Johnson, M. J., Leary, C., Maclaurin, D., ... & Zhang, Q. (2018). JAX: composable transformations of Python+ NumPy programs.","title":"References"},{"location":"glycolysis/","text":"Implementing glycolysis Rate-laws Interpolation Ask Joep whether the GP datasets are freely accessible, so that we can just share them as well.","title":"Glycolysis"},{"location":"glycolysis/#implementing-glycolysis","text":"","title":"Implementing glycolysis"},{"location":"glycolysis/#rate-laws","text":"","title":"Rate-laws"},{"location":"glycolysis/#interpolation","text":"Ask Joep whether the GP datasets are freely accessible, so that we can just share them as well.","title":"Interpolation"},{"location":"simulated-DBTL/","text":"Simulated design-build-test-learn-cycles","title":"Simulated-DBTL"},{"location":"simulated-DBTL/#simulated-design-build-test-learn-cycles","text":"","title":"Simulated design-build-test-learn-cycles"},{"location":"training_models/","text":"Training metabolic models","title":"Training models"},{"location":"training_models/#training-metabolic-models","text":"","title":"Training metabolic models"}]}