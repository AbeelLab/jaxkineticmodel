{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Summary Introduction A package for building, simulating and training kinetic models using Jax/Diffrax. Figure 1: Overview of the training procedure of SBML models being parameterized using techniques from neural differential equations . Installation Alternatively, the jaxkinetic model package can be installed using pip by cloning the repository and from the project folder doing: git clone https://github.com/AbeelLab/jaxkineticmodel.git python -m pip install . TO DO: archive package on pip to make it installable Minimal simulation example from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import matplotlib.pyplot as plt import pandas as pd import jax # define a reaction v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) # add reaction to a JaxKineticModelBuild class + compartment values reactions = [ v1 ] compartment_values = { 'c' : 1 } kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) # setup simulation ts = jnp . linspace ( 0 , 15 , 1000 ) y0 = jnp . array ([ 2 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 ]))) # solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) # plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 2: Simple reaction system simulation. References [1] Arxiv","title":"Home"},{"location":"#summary","text":"","title":"Summary"},{"location":"#introduction","text":"A package for building, simulating and training kinetic models using Jax/Diffrax. Figure 1: Overview of the training procedure of SBML models being parameterized using techniques from neural differential equations .","title":"Introduction"},{"location":"#installation","text":"Alternatively, the jaxkinetic model package can be installed using pip by cloning the repository and from the project folder doing: git clone https://github.com/AbeelLab/jaxkineticmodel.git python -m pip install . TO DO: archive package on pip to make it installable","title":"Installation"},{"location":"#minimal-simulation-example","text":"from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import matplotlib.pyplot as plt import pandas as pd import jax # define a reaction v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) # add reaction to a JaxKineticModelBuild class + compartment values reactions = [ v1 ] compartment_values = { 'c' : 1 } kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) # setup simulation ts = jnp . linspace ( 0 , 15 , 1000 ) y0 = jnp . array ([ 2 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 ]))) # solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) # plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 2: Simple reaction system simulation.","title":"Minimal simulation example"},{"location":"#references","text":"[1] Arxiv","title":"References"},{"location":"SBML/","text":"Loading SBML models SBML loader and simulation SBML models can be loaded and simulated as follows. from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import jax.numpy as jnp import pandas as pd filepath = ( \"models/sbml_models/working_models/simple_sbml.xml\" ) # load model from file_path model = SBMLModel ( filepath ) #replaces assignment rules, boundary conditions, etc.. S = model . _get_stoichiometric_matrix () JaxKmodel = model . get_kinetic_model () ts = jnp . linspace ( 0 , 100 , 2000 ) #simulate given the initial conditions defined in the sbml ys = JaxKmodel ( ts = ts , y0 = model . y0 , params = model . parameters ) ys = pd . DataFrame ( ys , columns = S . index ) SBML test-suite passed tests While jaxkineticmodel is compatible with SBML, not all .xml files are compatible/possible to simulate. This depends on the SBML model level and version that it was written. We here report a comparison in number of passed models with a comparison to libroadrunner using the sbml-test-suite . Libroadrunner is a high-performance simulation engine for systems biology. We compare the simulations to the gold-standard dataset that is provided in the sbml-test-suite. We selected 500 models from the test-suite and filtered out steady state models. Discrepancies are models where we compared the output from JaxKineticModel to the ground-truth data and observed differnces between the time-series. Overall, libroadrunner simulates more than jaxkineticmodel due to some event rules not yet being implemented. In the future we hope to address all these edge-cases. Test Name Similar Simulation Failed Simulation Discrepancies Total Last run jaxkineticmodel (l2v1) 169 68 52 289 15-02-25 libroadrunner (l2v1) 185 62 42 289 15-02-25 jaxkineticmodel (l2v2) 188 99 56 343 12-02-25 libroadrunner (l2v2) 219 68 56 343 12-02-25 jaxkineticmodel (l2v3) 189 98 56 343 12-02-25 libroadrunner (l2v3) 220 68 55 343 12-02-25 jaxkineticmodel (l2v4) 191 103 56 133 12-02-25 libroadrunner (l2v4) 219 73 58 133 12-02-25 jaxkineticmodel (l3v1) 173 206 62 441 12-02-25 libroadrunner (l3v1) 197 141 103 441 12-02-25 jaxkineticmodel (l3v2) 171 230 59 460 12-02-25 libroadrunner (l3v2) 197 160 103 460 12-02-25 References [1] Hass, H., Loos, C., Raimundez-Alvarez, E., Timmer, J., Hasenauer, J., & Kreutz, C. (2019). Benchmark problems for dynamic modeling of intracellular processes. Bioinformatics, 35(17), 3073-3082. [2]Somogyi, E. T., Bouteiller, J. M., Glazier, J. A., K\u00f6nig, M., Medley, J. K., Swat, M. H., & Sauro, H. M. (2015). libRoadRunner: a high performance SBML simulation and analysis library. Bioinformatics, 31(20), 3315-3321.","title":"Loading SBML models"},{"location":"SBML/#loading-sbml-models","text":"","title":"Loading SBML models"},{"location":"SBML/#sbml-loader-and-simulation","text":"SBML models can be loaded and simulated as follows. from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import jax.numpy as jnp import pandas as pd filepath = ( \"models/sbml_models/working_models/simple_sbml.xml\" ) # load model from file_path model = SBMLModel ( filepath ) #replaces assignment rules, boundary conditions, etc.. S = model . _get_stoichiometric_matrix () JaxKmodel = model . get_kinetic_model () ts = jnp . linspace ( 0 , 100 , 2000 ) #simulate given the initial conditions defined in the sbml ys = JaxKmodel ( ts = ts , y0 = model . y0 , params = model . parameters ) ys = pd . DataFrame ( ys , columns = S . index )","title":"SBML loader and simulation"},{"location":"SBML/#sbml-test-suite-passed-tests","text":"While jaxkineticmodel is compatible with SBML, not all .xml files are compatible/possible to simulate. This depends on the SBML model level and version that it was written. We here report a comparison in number of passed models with a comparison to libroadrunner using the sbml-test-suite . Libroadrunner is a high-performance simulation engine for systems biology. We compare the simulations to the gold-standard dataset that is provided in the sbml-test-suite. We selected 500 models from the test-suite and filtered out steady state models. Discrepancies are models where we compared the output from JaxKineticModel to the ground-truth data and observed differnces between the time-series. Overall, libroadrunner simulates more than jaxkineticmodel due to some event rules not yet being implemented. In the future we hope to address all these edge-cases. Test Name Similar Simulation Failed Simulation Discrepancies Total Last run jaxkineticmodel (l2v1) 169 68 52 289 15-02-25 libroadrunner (l2v1) 185 62 42 289 15-02-25 jaxkineticmodel (l2v2) 188 99 56 343 12-02-25 libroadrunner (l2v2) 219 68 56 343 12-02-25 jaxkineticmodel (l2v3) 189 98 56 343 12-02-25 libroadrunner (l2v3) 220 68 55 343 12-02-25 jaxkineticmodel (l2v4) 191 103 56 133 12-02-25 libroadrunner (l2v4) 219 73 58 133 12-02-25 jaxkineticmodel (l3v1) 173 206 62 441 12-02-25 libroadrunner (l3v1) 197 141 103 441 12-02-25 jaxkineticmodel (l3v2) 171 230 59 460 12-02-25 libroadrunner (l3v2) 197 160 103 460 12-02-25","title":"SBML test-suite passed tests"},{"location":"SBML/#references","text":"[1] Hass, H., Loos, C., Raimundez-Alvarez, E., Timmer, J., Hasenauer, J., & Kreutz, C. (2019). Benchmark problems for dynamic modeling of intracellular processes. Bioinformatics, 35(17), 3073-3082. [2]Somogyi, E. T., Bouteiller, J. M., Glazier, J. A., K\u00f6nig, M., Medley, J. K., Swat, M. H., & Sauro, H. M. (2015). libRoadRunner: a high performance SBML simulation and analysis library. Bioinformatics, 31(20), 3315-3321.","title":"References"},{"location":"building_models/","text":"Building models Metabolic kinetic modelling The time evolution of metabolic states are often described by a set of Ordinary Differential Equations (ODEs): $$\\frac{dm(t)}{dt}=S\\cdot v(t,m(t),\\theta)$$ \\(S\\) is the stoichiometric matrix that describes the mass balances of a metabolic system. The fluxes \\(v\\) are described by reaction mechanisms, typically of some form like Michaelis-Menten or Hill equations. These mechanisms are parameterized by \\(\\theta\\). By providing the initial values of the metabolic states, the ODEs can be solved using a numerical solver: $$m(T)=m(0)+\\int_0^T S\\cdot v(t,m(t),\\theta)dt$$ We will describe below how you can build your own models that are compatible with Jax/Diffrax [1] . The Reaction object A reaction-centric approach Models can be built in a reaction-centric manner. Initializing a Reaction object requires five inputs: name of the reaction, names of the species involved, stoichiometry of the reaction, compartments of the species involved, and the reaction's mechanism. #import import diffrax from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import jax import equinox import matplotlib.pyplot as plt import pandas as pd ReactionA = jkm . Reaction ( name = \"ReactionA\" , species = [ 'A' , 'B' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"A\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) The mechanism is another class that describes the flux function, which depends on metabolite states and parameters. Parameters are pointed towards with unique symbols. The reaction object is implemented in a way that own-implemented flux functions can be used. We have also implemented a set of general flux functions that are often used in systems biology. Table of implemented mechanisms Type of Reaction Name (in JAX class) Number of Parameters A \u2192 B Jax_MM_Irrev_Uni 2 A \u2192 B Jax_MM_Irrev_Uni_w_modifiers 2 + modifiers A \u2194 B Jax_MM_Rev_UniUni 4 A \u2192 Jax_MM_Sink 2 A \u2192 Jax_MA_Irrev 1 A \u21d2 Jax_Facilitated_Diffusion 3 A \u21d2 Jax_Diffusion 2 A + B \u2192 C Jax_MM_Irrev_Bi 3 Jax_MM_Irrev_Bi_w_Inhibition 3 Jax_MM_Irrev_Bi_w_modifiers 3 + modifiers A + B \u2194 C + D Jax_MM_Rev_BiBi 6 Jax_MM_Rev_BiBi_w_Inhibition 7 Jax_MM_Rev_BiBi_w_Activation 9 A + B \u2194 C + D Jax_MA_Rev_Bi 2 A \u2194 B + C Jax_MM_Rev_UniBi 5 A + B \u2192 C + D + E Jax_MM_Ordered_BiTri 7 A + B \u2192 C + D Jax_ADH 15 A \u2192 B + C Jax_Hill_Bi_Irreversible_Activation 7 A \u2192 B + C Jax_Hill_Irreversible_Inhibition 7 Building simple models A simple metabolic network example Here, we show an example of how to build kinetic models using the reaction objects described above. We model the following network: Three metabolic fluxes need to be modelled #Add reactions v1 to v3 v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) v2 = jkm . Reaction ( name = \"v2\" , species = [ 'm2' , 'm3' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"B_Vmax\" , km_substrate = \"B_Km\" ), ) v3 = jkm . Reaction ( name = \"v3\" , species = [ 'm2' , 'm4' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"C_Vmax\" , km_substrate = \"C_Km\" ), ) reactions = [ v1 , v2 , v3 ] compartment_values = { 'c' : 1 } # initialize the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) print ( kmodel . stoichiometric_matrix ) #define the time interval, and the initial conditions The stoichiometric matrix is automatically constructed from the reactions. v1 v2 v3 m1 -1.0 0.0 0.0 m2 1.0 -1.0 -1.0 m3 0.0 1.0 0.0 m4 0.0 0.0 1.0 One can first jax.jit the model [2] and solve the ODEs using the diffrax package [1] , which contains many nice numerical solvers. ts = jnp . linspace ( 0 , 10 , 1000 ) y0 = jnp . array ([ 2 , 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = equinox . filter_jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 1: ODE simulation. On jit-compiling kinetic models When you simulated a jit-compiled kinetic model for a certain time-range (e.g., jnp.linspace(0,10,1000) and you want to elongate this, it is best to not change the number of timepoints (e.g, jnp.linspace(0,1000,1000) . Otherwise, the kinetic models needs to be recompiled. Boundary conditions Boundary conditions can be either constant or not constant. Both are implemented as a BoundaryCondition class Constant boundary conditions Suppose for the system above, we want to make metabolite \\(m_1\\) a constant boundary condition. We can redefine the species by replacing it with a value kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '2' )) print ( kmodel . stoichiometric_matrix ) #recompile and simulate kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) #plot fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () Figure 2: ODE simulation with \\(m1=constant\\). Non-constant boundary conditions For non-constant boundary conditions, you can use the BoundaryCondition class as before. You can use for example the interpolation abstract classes from Diffrax . For analytic expression dependent on time t, these can be done as follows: # initialized the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '0.5+0.3*sin(t)' )) print ( kmodel . stoichiometric_matrix ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () Figure 3: ODE simulation with \\(m1=0+5+0.3*sin(t)\\). Changing the numerical solver The default solver is diffrax.kvaerno5 , but diffrax offers many other numerical solvers that might be more efficient for your purposes. Solvers can therefore be changed as follows. kmodel_sim = jkm . NeuralODEBuild ( kmodel ) kmodel_sim . _change_solver ( solver = diffrax . Kvaerno3 (), rtol = 1e-8 , atol = 1e-8 , icoeff = 0.1 ) Building custom models When building kinetic models, it is not uncommon that \\(\\frac{dm(t)}{dt}\\) is not fully based on the evaluation of \\(S\\cdot v(t)\\). For these cases, one can still use the kinetic mechanisms described above but with a manual setup of the ODEs. We have provided a custom implementation of glycolysis in Custom models as an example. Saving models Coming up References [1] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435. [2] Bradbury, J., Frostig, R., Hawkins, P., Johnson, M. J., Leary, C., Maclaurin, D., ... & Zhang, Q. (2018). JAX: composable transformations of Python+ NumPy programs.","title":"Building and simulating models"},{"location":"building_models/#building-models","text":"","title":"Building models"},{"location":"building_models/#metabolic-kinetic-modelling","text":"The time evolution of metabolic states are often described by a set of Ordinary Differential Equations (ODEs): $$\\frac{dm(t)}{dt}=S\\cdot v(t,m(t),\\theta)$$ \\(S\\) is the stoichiometric matrix that describes the mass balances of a metabolic system. The fluxes \\(v\\) are described by reaction mechanisms, typically of some form like Michaelis-Menten or Hill equations. These mechanisms are parameterized by \\(\\theta\\). By providing the initial values of the metabolic states, the ODEs can be solved using a numerical solver: $$m(T)=m(0)+\\int_0^T S\\cdot v(t,m(t),\\theta)dt$$ We will describe below how you can build your own models that are compatible with Jax/Diffrax [1] .","title":"Metabolic kinetic modelling"},{"location":"building_models/#the-reaction-object","text":"","title":"The Reaction object"},{"location":"building_models/#a-reaction-centric-approach","text":"Models can be built in a reaction-centric manner. Initializing a Reaction object requires five inputs: name of the reaction, names of the species involved, stoichiometry of the reaction, compartments of the species involved, and the reaction's mechanism. #import import diffrax from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm import jax.numpy as jnp import jax import equinox import matplotlib.pyplot as plt import pandas as pd ReactionA = jkm . Reaction ( name = \"ReactionA\" , species = [ 'A' , 'B' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"A\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) The mechanism is another class that describes the flux function, which depends on metabolite states and parameters. Parameters are pointed towards with unique symbols. The reaction object is implemented in a way that own-implemented flux functions can be used. We have also implemented a set of general flux functions that are often used in systems biology.","title":"A reaction-centric approach"},{"location":"building_models/#table-of-implemented-mechanisms","text":"Type of Reaction Name (in JAX class) Number of Parameters A \u2192 B Jax_MM_Irrev_Uni 2 A \u2192 B Jax_MM_Irrev_Uni_w_modifiers 2 + modifiers A \u2194 B Jax_MM_Rev_UniUni 4 A \u2192 Jax_MM_Sink 2 A \u2192 Jax_MA_Irrev 1 A \u21d2 Jax_Facilitated_Diffusion 3 A \u21d2 Jax_Diffusion 2 A + B \u2192 C Jax_MM_Irrev_Bi 3 Jax_MM_Irrev_Bi_w_Inhibition 3 Jax_MM_Irrev_Bi_w_modifiers 3 + modifiers A + B \u2194 C + D Jax_MM_Rev_BiBi 6 Jax_MM_Rev_BiBi_w_Inhibition 7 Jax_MM_Rev_BiBi_w_Activation 9 A + B \u2194 C + D Jax_MA_Rev_Bi 2 A \u2194 B + C Jax_MM_Rev_UniBi 5 A + B \u2192 C + D + E Jax_MM_Ordered_BiTri 7 A + B \u2192 C + D Jax_ADH 15 A \u2192 B + C Jax_Hill_Bi_Irreversible_Activation 7 A \u2192 B + C Jax_Hill_Irreversible_Inhibition 7","title":"Table of implemented mechanisms"},{"location":"building_models/#building-simple-models","text":"","title":"Building simple models"},{"location":"building_models/#a-simple-metabolic-network-example","text":"Here, we show an example of how to build kinetic models using the reaction objects described above. We model the following network: Three metabolic fluxes need to be modelled #Add reactions v1 to v3 v1 = jkm . Reaction ( name = \"v1\" , species = [ 'm1' , 'm2' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m1\" , vmax = \"A_Vmax\" , km_substrate = \"A_Km\" ), ) v2 = jkm . Reaction ( name = \"v2\" , species = [ 'm2' , 'm3' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"B_Vmax\" , km_substrate = \"B_Km\" ), ) v3 = jkm . Reaction ( name = \"v3\" , species = [ 'm2' , 'm4' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"m2\" , vmax = \"C_Vmax\" , km_substrate = \"C_Km\" ), ) reactions = [ v1 , v2 , v3 ] compartment_values = { 'c' : 1 } # initialize the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) print ( kmodel . stoichiometric_matrix ) #define the time interval, and the initial conditions The stoichiometric matrix is automatically constructed from the reactions. v1 v2 v3 m1 -1.0 0.0 0.0 m2 1.0 -1.0 -1.0 m3 0.0 1.0 0.0 m4 0.0 0.0 1.0 One can first jax.jit the model [2] and solve the ODEs using the diffrax package [1] , which contains many nice numerical solvers. ts = jnp . linspace ( 0 , 10 , 1000 ) y0 = jnp . array ([ 2 , 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = equinox . filter_jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm1' ], label = \"m1\" ) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () plt . show () Figure 1: ODE simulation.","title":"A simple metabolic network example"},{"location":"building_models/#on-jit-compiling-kinetic-models","text":"When you simulated a jit-compiled kinetic model for a certain time-range (e.g., jnp.linspace(0,10,1000) and you want to elongate this, it is best to not change the number of timepoints (e.g, jnp.linspace(0,1000,1000) . Otherwise, the kinetic models needs to be recompiled.","title":"On jit-compiling kinetic models"},{"location":"building_models/#boundary-conditions","text":"Boundary conditions can be either constant or not constant. Both are implemented as a BoundaryCondition class","title":"Boundary conditions"},{"location":"building_models/#constant-boundary-conditions","text":"Suppose for the system above, we want to make metabolite \\(m_1\\) a constant boundary condition. We can redefine the species by replacing it with a value kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '2' )) print ( kmodel . stoichiometric_matrix ) #recompile and simulate kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) #plot fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () Figure 2: ODE simulation with \\(m1=constant\\).","title":"Constant boundary conditions"},{"location":"building_models/#non-constant-boundary-conditions","text":"For non-constant boundary conditions, you can use the BoundaryCondition class as before. You can use for example the interpolation abstract classes from Diffrax . For analytic expression dependent on time t, these can be done as follows: # initialized the kinetic model object, and then make it a simulation object through jkm.NeuralODE kmodel = jkm . JaxKineticModelBuild ( reactions , compartment_values ) kmodel . add_boundary ( 'm1' , jkm . BoundaryCondition ( '0.5+0.3*sin(t)' )) print ( kmodel . stoichiometric_matrix ) kmodel_sim = jkm . NeuralODEBuild ( kmodel ) ts = jnp . linspace ( 0 , 10 , 1000 ) #we remove m1 from y0, as this is now not evaluated by solving y0 = jnp . array ([ 0 , 0 , 0 ]) params = dict ( zip ( kmodel . parameter_names , jnp . array ([ 1 , 1 , 1 , 1 , 1.5 , 1 ]))) #jit the kmodel object. This results in a slow initial solve, but a c-compiled solve kmodel_sim = jax . jit ( kmodel_sim ) ys = kmodel_sim ( ts , y0 , params ) ys = pd . DataFrame ( ys , columns = kmodel . species_names ) fig , ax = plt . subplots ( figsize = ( 4 , 4 )) ax . plot ( ts , ys [ 'm2' ], label = \"m2\" ) ax . plot ( ts , ys [ 'm3' ], label = \"m3\" ) ax . plot ( ts , ys [ 'm4' ], label = \"m4\" ) ax . set_xlabel ( \"Time (in seconds)\" ) ax . set_ylabel ( \"Concentration (in mM)\" ) ax . legend () Figure 3: ODE simulation with \\(m1=0+5+0.3*sin(t)\\).","title":"Non-constant boundary conditions"},{"location":"building_models/#changing-the-numerical-solver","text":"The default solver is diffrax.kvaerno5 , but diffrax offers many other numerical solvers that might be more efficient for your purposes. Solvers can therefore be changed as follows. kmodel_sim = jkm . NeuralODEBuild ( kmodel ) kmodel_sim . _change_solver ( solver = diffrax . Kvaerno3 (), rtol = 1e-8 , atol = 1e-8 , icoeff = 0.1 )","title":"Changing the numerical solver"},{"location":"building_models/#building-custom-models","text":"When building kinetic models, it is not uncommon that \\(\\frac{dm(t)}{dt}\\) is not fully based on the evaluation of \\(S\\cdot v(t)\\). For these cases, one can still use the kinetic mechanisms described above but with a manual setup of the ODEs. We have provided a custom implementation of glycolysis in Custom models as an example.","title":"Building custom models"},{"location":"building_models/#saving-models","text":"Coming up","title":"Saving models"},{"location":"building_models/#references","text":"[1] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435. [2] Bradbury, J., Frostig, R., Hawkins, P., Johnson, M. J., Leary, C., Maclaurin, D., ... & Zhang, Q. (2018). JAX: composable transformations of Python+ NumPy programs.","title":"References"},{"location":"glycolysis/","text":"Custom ODE models Not all kinetic model can be drafted only from stoichiometry. There are empirical laws that might influence There are many empirical laws that might influence reactions in the system of ODEs. Below, we present a reimplemented version [1] of a glycolysis model in Jax. We wil note down specific modeling choices that can be used to incorporate non-stoichiometric modifications. This output of this script can be found SBML model Rate laws We start by importing relevant modules from jaxkineticmodel . \"\"\"Implementation of the glycolysis model from Lao-Martil, D., Schmitz, J. P., Teusink, B., & van Riel, N. A. (2023). Elucidating yeast glycolytic dynamics at steady state growth and glucose pulses through kinetic metabolic modeling. Metabolic Engineering, 77, 128-142. Stoichiometry is changed according to the paper.\"\"\" import jax import jax.numpy as jnp import matplotlib.pyplot as plt import pandas as pd import sympy from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanismsCustom as jcm from jaxkineticmodel.kinetic_mechanisms import JaxKineticModifiers as modifier from jaxkineticmodel.load_sbml.export_sbml import SBMLExporter We define all reactions that are in the glycolysis model by using the Reaction object. This requires setting a name, species that are in the stoichiometry, the stoichiometry itself, and the mechanism used to compute. Note that metabolites (species) that only 'modify' a reaction, that is, they are involved in the reaction but not consumed or produced, should also be included in species list and stoichiometry as 0. v_glt = jkm . Reaction ( name = \"v_GLT\" , species = [ 'ECglucose' , 'ICglucose' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'e' , 'c' ], mechanism = jm . Jax_Facilitated_Diffusion ( substrate = \"ECglucose\" , product = \"ICglucose\" , vmax = \"p_GLT_VmGLT\" , km_internal = \"p_GLT_KmGLTGLCi\" , km_external = \"p_GLT_KmGLTGLCo\" , )) v_hxk = jkm . Reaction ( name = \"v_HXK\" , species = [ 'ICATP' , 'ICglucose' , \"ICADP\" , 'ICG6P' , \"ICT6P\" ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MM_Rev_BiBi_w_Inhibition ( substrate1 = \"ICATP\" , substrate2 = \"ICglucose\" , product1 = \"ICADP\" , product2 = \"ICATP\" , modifier = \"ICT6P\" , vmax = \"p_HXK_Vmax\" , k_equilibrium = \"p_HXK1_Keq\" , km_substrate1 = \"p_HXK1_Katp\" , km_substrate2 = \"p_HXK1_Kglc\" , km_product1 = \"p_HXK1_Kadp\" , km_product2 = \"p_HXK1_Kg6p\" , ki_inhibitor = \"p_HXK1_Kt6p\" , )) v_nth1 = jkm . Reaction ( name = \"v_NTH1\" , species = [ 'ICtreh' , 'ICglucose' ], stoichiometry = [ - 1 , 2 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"ICtreh\" , vmax = \"p_NTH1_Vmax\" , km_substrate = \"p_NTH1_Ktre\" )) v_pgi = jkm . Reaction ( name = \"v_PGI\" , species = [ 'ICG6P' , 'ICF6P' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"ICG6P\" , product = \"ICF6P\" , vmax = \"p_PGI1_Vmax\" , k_equilibrium = \"p_PGI1_Keq\" , km_substrate = \"p_PGI1_Kg6p\" , km_product = \"p_PGI1_Kf6p\" , )) v_sinkg6p = jkm . Reaction ( name = \"v_sinkG6P\" , species = [ 'ICG6P' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICG6P\" , v_sink = \"poly_sinkG6P\" , km_sink = \"km_sinkG6P\" )) v_sinkf6p = jkm . Reaction ( name = \"v_sinkf6P\" , species = [ 'ICF6P' , 'ICPHOS' ], stoichiometry = [ 1 , - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICF6P\" , v_sink = \"poly_sinkF6P\" , km_sink = \"km_sinkF6P\" )) v_pgm1 = jkm . Reaction ( name = \"v_PGM1\" , species = [ 'ICG1P' , 'ICG6P' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"ICG1P\" , product = \"ICG6P\" , vmax = \"p_PGM1_Vmax\" , k_equilibrium = \"p_PGM1_Keq\" , km_substrate = \"p_PGM1_Kg1p\" , km_product = \"p_PGM1_Kg6p\" )) # to do v_TPS1 for 2nd rate law The next mechanism is an example of adding a modifier structure to a pre-existing mechanism. This multiplies the calculated v by the modifier construct. ## look into how to deal with arbitrary arguments in compute() mech_tps1 = jm . Jax_MM_Irrev_Bi ( substrate1 = \"ICG6P\" , substrate2 = \"ICG1P\" , vmax = \"p_TPS1_Vmax\" , km_substrate1 = \"p_TPS1_Kg6p\" , km_substrate2 = \"p_TPS1_Kudp_glc\" , ) mech_tps1 . add_modifier ( modifier . SimpleActivator ( activator = \"ICF6P\" , k_A = \"p_TPS1_KmF6P\" )) #modifiers need to be added with 0 stoichiometry v_tps1 = jkm . Reaction ( name = \"v_TPS1\" , species = [ 'ICG6P' , 'ICG1P' , 'ICATP' , 'ICT6P' , 'ICADP' , 'ICPHOS' , 'ICF6P' ], stoichiometry = [ - 1 , - 1 , - 1 , 1 , 1 , 2 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' , 'c' ], mechanism = mech_tps1 ) Some other reactions v_tps2 = jkm . Reaction ( name = \"v_TPS2\" , species = [ \"ICT6P\" , \"ICtreh\" , \"ICPHOS\" ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MM_Irrev_Bi_w_Inhibition ( substrate = \"ICT6P\" , product = \"ICPHOS\" , vmax = \"p_TPS2_Vmax\" , km_substrate1 = \"p_TPS2_Kt6p\" , ki = \"p_TPS2_Kpi\" )) v_pfk = jkm . Reaction ( name = \"v_PFK\" , species = [ 'ICF6P' , 'ICATP' , 'ICFBP' , 'ICADP' , 'ICAMP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_PFK ( substrate1 = \"ICF6P\" , substrate2 = \"ICATP\" , product = \"ICFBP\" , modifiers = \"ICAMP\" , vmax = \"p_PFK_Vmax\" , kr_F6P = \"p_PFK_Kf6p\" , kr_ATP = \"p_PFK_Katp\" , gr = \"p_PFK_gR\" , c_ATP = \"p_PFK_Catp\" , ci_ATP = \"p_PFK_Ciatp\" , ci_AMP = \"p_PFK_Camp\" , ci_F26BP = \"p_PFK_Cf26bp\" , ci_F16BP = \"p_PFK_Cf16bp\" , l = \"p_PFK_L\" , kATP = \"p_PFK_Kiatp\" , kAMP = \"p_PFK_Kamp\" , F26BP = \"p_PFK_F26BP\" , kF26BP = \"p_PFK_Kf26bp\" , kF16BP = \"p_PFK_Kf16bp\" )) v_ald = jkm . Reaction ( name = \"v_ALD\" , species = [ 'ICFBP' , 'ICGAP' , 'ICDHAP' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniBi ( substrate = \"ICFBP\" , product1 = \"ICGAP\" , product2 = \"ICDHAP\" , vmax = \"p_FBA1_Vmax\" , k_equilibrium = \"p_FBA1_Keq\" , km_substrate = \"p_FBA1_Kf16bp\" , km_product1 = \"p_FBA1_Kglyceral3p\" , km_product2 = \"p_FBA1_Kdhap\" , )) v_tpi1 = jkm . Reaction ( name = \"v_TPI1\" , species = [ 'ICDHAP' , 'ICGAP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"ICDHAP\" , product = \"ICGAP\" , vmax = \"p_TPI1_Vmax\" , k_equilibrium = \"p_TPI1_Keq\" , km_substrate = \"p_TPI1_Kdhap\" , km_product = \"p_TPI1_Kglyceral3p\" , )) v_sinkgap = jkm . Reaction ( name = \"v_sinkGAP\" , species = [ 'ICGAP' , 'ICPHOS' ], stoichiometry = [ 1 , - 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICGAP\" , v_sink = \"poly_sinkGAP\" , km_sink = \"poly_sinkGAP\" )) ## look into how to deal with arbitrary arguments in compute() v_g3pdh = jkm . Reaction ( name = \"v_3GPDH\" , species = [ 'ICDHAP' , 'ICNADH' , 'ICG3P' , 'ICNAD' , 'ICFBP' , 'ICATP' , 'ICADP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 , 0 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . G3PDH_Func_TEMP ( substrate1 = \"ICDHAP\" , substrate2 = \"ICNADH\" , product1 = \"ICG3P\" , product2 = \"ICNAD\" , modifier1 = \"ICFBP\" , modifier2 = \"ICATP\" , modifier3 = \"ICADP\" , vmax = \"p_GPD1_Vmax\" , k_equilibrium = \"p_GPD1_Keq\" , km_substrate1 = \"p_GPD1_Kdhap\" , km_substrate2 = \"p_GPD1_Knadh\" , km_product1 = \"p_GPD1_Kglyc3p\" , km_product2 = \"p_GPD1_Knad\" , ka1 = \"p_GPD1_Kf16bp\" , ka2 = \"p_GPD1_Katp\" , ka3 = \"p_GPD1_Kadp\" , )) v_gapdh = jkm . Reaction ( name = \"v_GAPDH\" , species = [ 'ICGAP' , 'ICNAD' , 'ICPHOS' , 'ICBPG' , 'ICNADH' ], stoichiometry = [ - 1 , - 1 , - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MM_Ordered_Bi_Tri ( substrate1 = \"ICGAP\" , substrate2 = \"ICNAD\" , substrate3 = \"ICPHOS\" , product1 = \"ICBPG\" , product2 = \"ICNADH\" , vmax = \"p_GAPDH_Vmax\" , k_equilibrium = \"p_TDH1_Keq\" , km_substrate1 = \"p_TDH1_Kglyceral3p\" , km_substrate2 = \"p_TDH1_Knad\" , ki = \"p_TDH1_Kpi\" , km_product1 = \"p_TDH1_Kglycerate13bp\" , km_product2 = \"p_TDH1_Knadh\" )) v_pgk = jkm . Reaction ( name = \"v_PGK\" , species = [ 'ICBPG' , 'ICADP' , 'IC3PG' , 'ICATP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_BiBi ( substrate1 = \"ICBPG\" , substrate2 = \"ICADP\" , product1 = \"IC3PG\" , product2 = \"ICATP\" , vmax = \"p_PGK_VmPGK\" , k_equilibrium = \"p_PGK_KeqPGK\" , km_substrate1 = \"p_PGK_KmPGKBPG\" , km_substrate2 = \"p_PGK_KmPGKADP\" , km_product1 = \"p_PGK_KmPGKP3G\" , km_product2 = \"p_PGK_KmPGKATP\" , )) v_sink3pga = jkm . Reaction ( name = \"v_sink3PGA\" , species = [ 'IC3PG' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"IC3PG\" , v_sink = \"poly_sinkP3G\" , km_sink = \"km_sinkP3G\" )) mech_hor2 = jm . Jax_MM_Irrev_Uni ( substrate = \"ICG3P\" , vmax = \"p_HOR2_Vmax\" , km_substrate = \"p_HOR2_Kglyc3p\" ) mech_hor2 . add_modifier ( modifier . SimpleInhibitor ( inhibitor = \"ICPHOS\" , k_I = \"p_HOR2_Kpi\" )) ## look into how to deal with arbitrary arguments in compute() v_hor2 = jkm . Reaction ( name = \"v_HOR2\" , species = [ 'ICG3P' , 'ICglyc' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = mech_hor2 ) ### next up v_GlycT mech_glyct_ic = jm . Jax_Diffusion ( substrate = \"ICglyc\" , enzyme = \"f_GLYCEROL_e\" , transport_coef = \"p_GlycerolTransport\" ) v_glyct_ic = jkm . Reaction ( name = \"v_GlycT_IC\" , species = [ 'ICglyc' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = mech_glyct_ic ) mech_glyct_ec = jm . Jax_Diffusion ( substrate = \"ICglyc\" , enzyme = \"f_GLYCEROL_e\" , transport_coef = \"p_GlycerolTransport\" ) mech_glyct_ec . add_modifier ( modifier . BiomassModifier ( biomass = \"ECbiomass\" )) v_glyct_ec = jkm . Reaction ( name = \"v_GlycT_EC\" , species = [ 'ICglyc' , 'ECglyc' ], stoichiometry = [ 0 , 1 ], compartments = [ 'c' , 'e' ], mechanism = mech_glyct_ec ) v_pgm = jkm . Reaction ( name = \"v_PGM\" , species = [ 'IC3PG' , 'IC2PG' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"IC3PG\" , product = \"IC2PG\" , vmax = \"p_PGM_Vm\" , k_equilibrium = \"p_PGM_Keq\" , km_substrate = \"p_PGM_K3pg\" , km_product = \"p_PGM_K2pg\" , )) v_eno2 = jkm . Reaction ( name = \"v_ENO2\" , species = [ 'IC2PG' , 'ICPEP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"IC2PG\" , product = \"ICPEP\" , vmax = \"p_ENO1_Vm\" , k_equilibrium = \"p_ENO1_Keq\" , km_substrate = \"p_ENO1_K2pg\" , km_product = \"p_ENO1_Kpep\" , )) v_sinkpep = jkm . Reaction ( name = \"v_sinkPEP\" , species = [ 'ICPEP' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICPEP\" , v_sink = \"poly_sinkPEP\" , km_sink = \"km_sinkPEP\" )) v_pyk1 = jkm . Reaction ( name = 'v_PYK1' , species = [ 'ICPEP' , 'ICADP' , 'ICPYR' , 'ICATP' , 'ICFBP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_Hill_Irreversible_Bi_Activation ( substrate1 = \"ICPEP\" , substrate2 = \"ICADP\" , activator = \"ICFBP\" , product = \"ICATP\" , vmax = \"p_PYK1_Vm\" , hill = \"p_PYK1_hill\" , k_substrate1 = \"p_PYK1_Kpep\" , k_substrate2 = \"p_PYK1_Kadp\" , k_product = \"p_PYK1_Katp\" , k_activator = \"p_PYK1_Kf16bp\" , l = \"p_PYK1_L\" , )) v_sinkpyr = jkm . Reaction ( name = 'v_sinkPYR' , species = [ 'ICPYR' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICPYR\" , v_sink = \"poly_sinkPYR\" , km_sink = \"km_sinkPYR\" )) v_adh = jkm . Reaction ( name = 'v_ADH' , species = [ 'ICNAD' , 'ICETOH' , 'ICNADH' , 'ICACE' ], stoichiometry = [ 1 , 1 , - 1 , - 1 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_ADH ( NAD = \"ICNAD\" , ETOH = \"ICETOH\" , NADH = \"ICNADH\" , ACE = \"ICACE\" , vmax = \"p_ADH_VmADH\" , k_equilibrium = \"p_ADH_KeqADH\" , km_substrate1 = \"p_ADH_KiADHNAD\" , km_substrate2 = \"p_ADH_KmADHETOH\" , km_product1 = \"p_ADH_KmADHACE\" , km_product2 = \"p_ADH_KmADHNADH\" , ki_substrate1 = \"p_ADH_KiADHNAD\" , ki_substrate2 = \"p_ADH_KiADHETOH\" , ki_product1 = \"p_ADH_KiADHACE\" , ki_product2 = \"p_ADH_KiADHNADH\" , exprs_cor = \"p_ADH_ExprsCor\" , )) v_sinkace = jkm . Reaction ( name = 'v_sinkACE' , species = [ 'ICACE' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICACE\" , v_sink = \"poly_sinkACE\" , km_sink = \"km_sinkACE\" )) #from a modelling perspective this is awkward. we have a rate that only needs to be modified for ECETOH, not ICETOH. # where therefore need to split the stoichiometry as well, while maintaining the same parameters mech_etoht_ic = jm . Jax_Diffusion ( substrate = \"ICETOH\" , enzyme = \"f_ETOH_e\" , transport_coef = \"p_kETOHtransport\" ) Sometimes, a flux may need to be scaled differently per ODEs. Suppose we have the original mass-balances in the glycolysis model, where for the intracellular concentration we do not scale the flux, but for the extracellular we do. $$\\frac{d etoh_{ic}}{dt}=- v_{ETOHT} + ... $$ $$\\frac{d etoh_{ec}}{dt}=+ v_{ETOHT} * [biomass] * 0.002 + ... $$ We can first define a mechanisms for ICETOH and then modify this for ECETOH. This requires us to use two Reaction objects, and set stoichiometry to 0 to ensure that they are not wrongly affected by the scaling. #only outgoing v_etoht_ic = jkm . Reaction ( name = \"v_ETOHT_IC\" , species = [ 'ICETOH' ], stoichiometry = [ - 1 , 0 ], compartments = [ 'c' ], mechanism = mech_etoht_ic ) mech_etoht_ec = jm . Jax_Diffusion ( substrate = \"ICETOH\" , enzyme = \"f_ETOH_e\" , transport_coef = \"p_kETOHtransport\" ) mech_etoht_ec . add_modifier ( modifier . BiomassModifier ( biomass = 'ECbiomass' )) v_etoht_ec = jkm . Reaction ( name = \"v_ETOHT_EC\" , species = [ 'ICETOH' , 'ECETOH' ], stoichiometry = [ 0 , 1 ], compartments = [ 'c' , 'e' ], mechanism = mech_etoht_ec ) Further finish the reaction definitions v_atpmito = jkm . Reaction ( name = 'v_ATPMITO' , species = [ 'ICATP' , 'ICPHOS' , 'ICADP' ], stoichiometry = [ 1 , - 1 , - 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Bi ( substrate1 = \"ICADP\" , substrate2 = \"ICPHOS\" , vmax = \"p_mitoVmax\" , km_substrate1 = \"p_mitoADPKm\" , km_substrate2 = \"p_mitoPiKm\" )) v_atpase = jkm . Reaction ( name = \"v_ATPASE\" , species = [ 'ICATP' , 'ICPHOS' , 'ICADP' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jcm . Jax_ATPase ( substrate = \"ICATP\" , product = \"ICADP\" , ATPase_ratio = \"p_ATPase_ratio\" )) v_adk = jkm . Reaction ( name = \"v_ADK\" , species = [ 'ICADP' , 'ICATP' , 'ICAMP' ], stoichiometry = [ - 2 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MA_Rev_Bi ( substrate1 = \"ICADP\" , substrate2 = \"ICADP\" , product1 = \"ICATP\" , product2 = \"ICAMP\" , k_equilibrium = \"p_ADK1_Keq\" , k_fwd = \"p_ADK1_k\" )) v_vacpi = jkm . Reaction ( name = \"v_VACPI\" , species = [ 'ICPHOS' ], stoichiometry = [ 1 ], compartments = [ 'c' ], mechanism = jcm . Jax_MA_Rev ( substrate = \"ICPHOS\" , k = \"p_vacuolePi_k\" , steady_state_substrate = \"p_vacuolePi_steadyStatePi\" ) ) v_amd1 = jkm . Reaction ( name = \"v_AMD1\" , species = [ 'ICAMP' , 'ICIMP' , 'ICATP' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 , 0 , 0 ], compartments = [ 'c' , 'c' ], mechanism = jcm . Jax_Amd1 ( substrate = \"ICAMP\" , product = \"ICATP\" , modifier = \"ICPHOS\" , vmax = \"p_Amd1_Vmax\" , k50 = \"p_Amd1_K50\" , ki = \"p_Amd1_Kpi\" , k_atp = \"p_Amd1_Katp\" , )) v_ade1312 = jkm . Reaction ( name = \"v_ADE1312\" , species = [ 'ICIMP' , 'ICAMP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Ade13_Ade12_k\" )) v_isn1 = jkm . Reaction ( name = \"v_ISN1\" , species = [ 'ICIMP' , 'ICPHOS' , 'ICINO' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Isn1_k\" )) v_pnp1 = jkm . Reaction ( name = \"v_PNP1\" , species = [ 'ICINO' , 'ICHYP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICINO\" , k_fwd = \"p_Pnp1_k\" )) v_hpt1 = jkm . Reaction ( name = \"v_HPT1\" , species = [ 'ICIMP' , 'ICPHOS' , 'ICHYP' ], stoichiometry = [ 1 , - 1 , - 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICHYP\" , k_fwd = \"p_Hpt1_k\" )) #v_pdcs v_pdc = jkm . Reaction ( name = \"v_PDC\" , species = [ 'ICPYR' , 'ICACE' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 , 0 ], compartments = [ 'c' , 'c' ], mechanism = jcm . Jax_Hill_Irreversible_Inhibition ( substrate = \"ICPYR\" , inhibitor = \"ICPHOS\" , vmax = \"p_PDC1_Vmax\" , k_half_substrate = \"p_PDC1_Kpyr\" , hill = \"p_PDC1_hill\" , ki = \"p_PDC1_Kpi\" , )) v_mitonadh = jkm . Reaction ( name = \"v_MITONADH\" , species = [ 'ICNADH' , 'ICNAD' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM ( substrate = \"ICNADH\" , vmax = \"p_mitoNADHVmax\" , km = \"p_mitoNADHKm\" )) # I think this can be replaced by Jax_MM_Irrev_Uni v_ugp = jkm . Reaction ( name = \"v_UGP\" , species = [ 'ICG1P' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_Constant_Flux ( v = \"flux_ugp\" )) #modification to mimic the glycolysis model v_transport_reactions = jkm . Reaction ( name = \"v_TRANSPORT\" , species = [ 'ECETOH' , 'ECglyc' ], compartments = [ 'e' , 'e' ], stoichiometry = [ - 1 , - 1 ], mechanism = jcm . Jax_Transport_Flux_Correction ( substrate = \"ECETOH\" , dilution_rate = 'D' ) ) Setting up the ODE system We now pass all reactions and compartment definitions to JaxKineticModelBuild , similarly to how it was performed in the Building Models tutorial. ## we can add modifications to mechanism through the JaxKineticModelBuild obejct compartments = { 'c' : 1 , 'e' : 1 } reactions = [ v_hxk , v_glt , v_nth1 , v_pgi , v_sinkg6p , v_sinkf6p , v_pgm1 , v_tps1 , v_tps2 , v_pfk , v_ald , v_tpi1 , v_sinkgap , v_g3pdh , v_gapdh , v_pgk , v_sink3pga , v_hor2 , v_glyct_ic , v_glyct_ec , v_pgm , v_eno2 , v_sinkpep , v_pyk1 , v_sinkpyr , v_adh , v_sinkace , v_etoht_ic , v_etoht_ec , v_atpmito , v_atpase , v_adk , v_vacpi , v_amd1 , v_ade1312 , v_isn1 , v_pnp1 , v_hpt1 , v_pdc , v_mitonadh , v_ugp , v_transport_reactions ] kmodel = jkm . JaxKineticModelBuild ( reactions , compartments ) Cubic spline boundary condition As mentioned in the Building Models tutorial, we can add boundary conditions for species that are either constant or time-dependent. Often, it is necessary to do interpolation, such as cubic spline, to model a perturbation. We can build expressions for that using sympy, pass these as a string input to the boundary condition class, which builds the cubic spline for us, that can be exported to an sbml. # do an interpolation using sympy for EC glucose and add as a boundary condition data = pd . read_csv ( 'datasets/VanHeerden_Glucose_Pulse/FF1_timeseries_format.csv' , index_col = 0 ) domain = [ float ( i ) for i in data . loc [ 'ECglucose' ] . dropna () . index ] d_range = data . loc [ 'ECglucose' ] . dropna () . values t = sympy . Symbol ( 't' ) spline = sympy . interpolating_spline ( 3 , t , domain , d_range ) print ( 'true spline' , spline ) spline = str ( spline ) kmodel . add_boundary ( 'ECglucose' , jkm . BoundaryCondition ( spline )) Parameters and initial conditions We add parameters from literature values and the initial conditions are initialized. kmodel_sim = jkm . NeuralODEBuild ( kmodel ) S = kmodel . stoichiometric_matrix lit_params = pd . read_csv (( 'parameter_initializations/' 'Glycolysis_model/' 'parameter_initialization_glycolysis' '_literature_values.csv' ), index_col = 0 ) . to_dict ()[ '0' ] D = 0.1 parameters = {} for name in kmodel . parameter_names : #need to deal with the poly_sinks dependent on dilution rate if name in lit_params . keys (): parameters [ name ] = lit_params [ name ] else : if name == 'poly_sinkG6P' : parameters [ name ] = float ( jnp . abs ( 3.6854 * D ** 3 - 1.4119 * D ** 2 - 0.6312 * D - 0.0043 )) elif name == 'poly_sinkF6P' : parameters [ name ] = float ( jnp . abs ( 519.3740 * D ** 6 - 447.7990 * D ** 5 + 97.2843 * D ** 4 + 8.0698 * D ** 3 - 4.4005 * D ** 2 + 0.6254 * D - 0.0078 )) elif name == 'poly_sinkP3G' : parameters [ name ] = float ( jnp . abs ( - 0.2381 * D ** 2 - 0.0210 * D - 0.0034 )) elif name == 'poly_sinkPEP' : parameters [ name ] = float ( jnp . abs ( - 0.0637 * D ** 2 - 0.0617 * D - 0.0008 )) elif name == 'poly_sinkPYR' : parameters [ name ] = float ( jnp . abs ( - 8.4853e03 * D ** 6 + 9.4027e03 * D ** 5 - 3.8027e03 * D ** 4 + 700.5 * D ** 3 - 60.26 * D ** 2 + 0.711 * D - 0.0356 )) elif name == 'poly_sinkACE' : parameters [ name ] = float ( jnp . abs ( 118.8562 * D ** 6 - 352.3943 * D ** 5 + 245.6092 * D ** 4 - 75.2550 * D ** 3 + 11.1153 * D ** 2 - 1.0379 * D + 0.0119 )) elif name == 'ECbiomass' : parameters [ name ] = float ( 3.7683659 ) elif name == \"D\" : parameters [ name ] = float ( D ) y0_dict = { \"ICG1P\" : 0.064568 , \"ICT6P\" : 0.093705 , \"ICtreh\" : 63.312040 , \"ICglucose\" : 0.196003 , \"ICG6P\" : 0.716385 , \"ICF6P\" : 0.202293 , \"ICFBP\" : 0.057001 , \"ICDHAP\" : 0.048571 , \"ICG3P\" : 0.020586 , \"ICglyc\" : 0.1 , \"ICGAP\" : 0.006213 , \"ICBPG\" : 0.0001 , \"IC3PG\" : 2.311074 , \"IC2PG\" : 0.297534 , \"ICPEP\" : 1.171415 , \"ICPYR\" : 0.152195 , \"ICACE\" : 0.04 , \"ICETOH\" : 10.0 , \"ECETOH\" : 0 , \"ECglyc\" : 0.0 , \"ICNADH\" : 0.0106 , \"ICNAD\" : 1.5794 , \"ICATP\" : 3.730584 , \"ICADP\" : 1.376832 , \"ICAMP\" : 0.431427 , \"ICPHOS\" : 10 , \"ICIMP\" : 0.100 , \"ICINO\" : 0.100 , \"ICHYP\" : 1.5 , } y0 = [] for meta in kmodel . species_names : if meta in y0_dict . keys (): y0 . append ( y0_dict [ meta ]) else : print ( meta ) y0 . append ( 1 ) y0 = jnp . array ( y0 ) Exporting the model The model can be exported to sbml format for parameter optimziation. output_dir = \"models/manual_implementations/sbml_export/\" model_name = \"glycolysis_feastfamine_pulse1\" sbml = SBMLExporter ( model = kmodel_sim ) sbml . export ( initial_conditions = y0 , parameters = parameters , output_file = f \" { output_dir } / { model_name } .xml\" ) References [1] Lao-Martil, D., Schmitz, J. P., Teusink, B., & van Riel, N. A. (2023). Elucidating yeast glycolytic dynamics at steady state growth and glucose pulses through kinetic metabolic modeling. Metabolic engineering, 77, 128-142.","title":"Custom models"},{"location":"glycolysis/#custom-ode-models","text":"Not all kinetic model can be drafted only from stoichiometry. There are empirical laws that might influence There are many empirical laws that might influence reactions in the system of ODEs. Below, we present a reimplemented version [1] of a glycolysis model in Jax. We wil note down specific modeling choices that can be used to incorporate non-stoichiometric modifications. This output of this script can be found SBML model","title":"Custom ODE models"},{"location":"glycolysis/#rate-laws","text":"We start by importing relevant modules from jaxkineticmodel . \"\"\"Implementation of the glycolysis model from Lao-Martil, D., Schmitz, J. P., Teusink, B., & van Riel, N. A. (2023). Elucidating yeast glycolytic dynamics at steady state growth and glucose pulses through kinetic metabolic modeling. Metabolic Engineering, 77, 128-142. Stoichiometry is changed according to the paper.\"\"\" import jax import jax.numpy as jnp import matplotlib.pyplot as plt import pandas as pd import sympy from jaxkineticmodel.building_models import JaxKineticModelBuild as jkm from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanisms as jm from jaxkineticmodel.kinetic_mechanisms import JaxKineticMechanismsCustom as jcm from jaxkineticmodel.kinetic_mechanisms import JaxKineticModifiers as modifier from jaxkineticmodel.load_sbml.export_sbml import SBMLExporter We define all reactions that are in the glycolysis model by using the Reaction object. This requires setting a name, species that are in the stoichiometry, the stoichiometry itself, and the mechanism used to compute. Note that metabolites (species) that only 'modify' a reaction, that is, they are involved in the reaction but not consumed or produced, should also be included in species list and stoichiometry as 0. v_glt = jkm . Reaction ( name = \"v_GLT\" , species = [ 'ECglucose' , 'ICglucose' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'e' , 'c' ], mechanism = jm . Jax_Facilitated_Diffusion ( substrate = \"ECglucose\" , product = \"ICglucose\" , vmax = \"p_GLT_VmGLT\" , km_internal = \"p_GLT_KmGLTGLCi\" , km_external = \"p_GLT_KmGLTGLCo\" , )) v_hxk = jkm . Reaction ( name = \"v_HXK\" , species = [ 'ICATP' , 'ICglucose' , \"ICADP\" , 'ICG6P' , \"ICT6P\" ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MM_Rev_BiBi_w_Inhibition ( substrate1 = \"ICATP\" , substrate2 = \"ICglucose\" , product1 = \"ICADP\" , product2 = \"ICATP\" , modifier = \"ICT6P\" , vmax = \"p_HXK_Vmax\" , k_equilibrium = \"p_HXK1_Keq\" , km_substrate1 = \"p_HXK1_Katp\" , km_substrate2 = \"p_HXK1_Kglc\" , km_product1 = \"p_HXK1_Kadp\" , km_product2 = \"p_HXK1_Kg6p\" , ki_inhibitor = \"p_HXK1_Kt6p\" , )) v_nth1 = jkm . Reaction ( name = \"v_NTH1\" , species = [ 'ICtreh' , 'ICglucose' ], stoichiometry = [ - 1 , 2 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Uni ( substrate = \"ICtreh\" , vmax = \"p_NTH1_Vmax\" , km_substrate = \"p_NTH1_Ktre\" )) v_pgi = jkm . Reaction ( name = \"v_PGI\" , species = [ 'ICG6P' , 'ICF6P' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"ICG6P\" , product = \"ICF6P\" , vmax = \"p_PGI1_Vmax\" , k_equilibrium = \"p_PGI1_Keq\" , km_substrate = \"p_PGI1_Kg6p\" , km_product = \"p_PGI1_Kf6p\" , )) v_sinkg6p = jkm . Reaction ( name = \"v_sinkG6P\" , species = [ 'ICG6P' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICG6P\" , v_sink = \"poly_sinkG6P\" , km_sink = \"km_sinkG6P\" )) v_sinkf6p = jkm . Reaction ( name = \"v_sinkf6P\" , species = [ 'ICF6P' , 'ICPHOS' ], stoichiometry = [ 1 , - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICF6P\" , v_sink = \"poly_sinkF6P\" , km_sink = \"km_sinkF6P\" )) v_pgm1 = jkm . Reaction ( name = \"v_PGM1\" , species = [ 'ICG1P' , 'ICG6P' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"ICG1P\" , product = \"ICG6P\" , vmax = \"p_PGM1_Vmax\" , k_equilibrium = \"p_PGM1_Keq\" , km_substrate = \"p_PGM1_Kg1p\" , km_product = \"p_PGM1_Kg6p\" )) # to do v_TPS1 for 2nd rate law The next mechanism is an example of adding a modifier structure to a pre-existing mechanism. This multiplies the calculated v by the modifier construct. ## look into how to deal with arbitrary arguments in compute() mech_tps1 = jm . Jax_MM_Irrev_Bi ( substrate1 = \"ICG6P\" , substrate2 = \"ICG1P\" , vmax = \"p_TPS1_Vmax\" , km_substrate1 = \"p_TPS1_Kg6p\" , km_substrate2 = \"p_TPS1_Kudp_glc\" , ) mech_tps1 . add_modifier ( modifier . SimpleActivator ( activator = \"ICF6P\" , k_A = \"p_TPS1_KmF6P\" )) #modifiers need to be added with 0 stoichiometry v_tps1 = jkm . Reaction ( name = \"v_TPS1\" , species = [ 'ICG6P' , 'ICG1P' , 'ICATP' , 'ICT6P' , 'ICADP' , 'ICPHOS' , 'ICF6P' ], stoichiometry = [ - 1 , - 1 , - 1 , 1 , 1 , 2 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' , 'c' ], mechanism = mech_tps1 ) Some other reactions v_tps2 = jkm . Reaction ( name = \"v_TPS2\" , species = [ \"ICT6P\" , \"ICtreh\" , \"ICPHOS\" ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MM_Irrev_Bi_w_Inhibition ( substrate = \"ICT6P\" , product = \"ICPHOS\" , vmax = \"p_TPS2_Vmax\" , km_substrate1 = \"p_TPS2_Kt6p\" , ki = \"p_TPS2_Kpi\" )) v_pfk = jkm . Reaction ( name = \"v_PFK\" , species = [ 'ICF6P' , 'ICATP' , 'ICFBP' , 'ICADP' , 'ICAMP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_PFK ( substrate1 = \"ICF6P\" , substrate2 = \"ICATP\" , product = \"ICFBP\" , modifiers = \"ICAMP\" , vmax = \"p_PFK_Vmax\" , kr_F6P = \"p_PFK_Kf6p\" , kr_ATP = \"p_PFK_Katp\" , gr = \"p_PFK_gR\" , c_ATP = \"p_PFK_Catp\" , ci_ATP = \"p_PFK_Ciatp\" , ci_AMP = \"p_PFK_Camp\" , ci_F26BP = \"p_PFK_Cf26bp\" , ci_F16BP = \"p_PFK_Cf16bp\" , l = \"p_PFK_L\" , kATP = \"p_PFK_Kiatp\" , kAMP = \"p_PFK_Kamp\" , F26BP = \"p_PFK_F26BP\" , kF26BP = \"p_PFK_Kf26bp\" , kF16BP = \"p_PFK_Kf16bp\" )) v_ald = jkm . Reaction ( name = \"v_ALD\" , species = [ 'ICFBP' , 'ICGAP' , 'ICDHAP' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniBi ( substrate = \"ICFBP\" , product1 = \"ICGAP\" , product2 = \"ICDHAP\" , vmax = \"p_FBA1_Vmax\" , k_equilibrium = \"p_FBA1_Keq\" , km_substrate = \"p_FBA1_Kf16bp\" , km_product1 = \"p_FBA1_Kglyceral3p\" , km_product2 = \"p_FBA1_Kdhap\" , )) v_tpi1 = jkm . Reaction ( name = \"v_TPI1\" , species = [ 'ICDHAP' , 'ICGAP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"ICDHAP\" , product = \"ICGAP\" , vmax = \"p_TPI1_Vmax\" , k_equilibrium = \"p_TPI1_Keq\" , km_substrate = \"p_TPI1_Kdhap\" , km_product = \"p_TPI1_Kglyceral3p\" , )) v_sinkgap = jkm . Reaction ( name = \"v_sinkGAP\" , species = [ 'ICGAP' , 'ICPHOS' ], stoichiometry = [ 1 , - 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICGAP\" , v_sink = \"poly_sinkGAP\" , km_sink = \"poly_sinkGAP\" )) ## look into how to deal with arbitrary arguments in compute() v_g3pdh = jkm . Reaction ( name = \"v_3GPDH\" , species = [ 'ICDHAP' , 'ICNADH' , 'ICG3P' , 'ICNAD' , 'ICFBP' , 'ICATP' , 'ICADP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 , 0 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . G3PDH_Func_TEMP ( substrate1 = \"ICDHAP\" , substrate2 = \"ICNADH\" , product1 = \"ICG3P\" , product2 = \"ICNAD\" , modifier1 = \"ICFBP\" , modifier2 = \"ICATP\" , modifier3 = \"ICADP\" , vmax = \"p_GPD1_Vmax\" , k_equilibrium = \"p_GPD1_Keq\" , km_substrate1 = \"p_GPD1_Kdhap\" , km_substrate2 = \"p_GPD1_Knadh\" , km_product1 = \"p_GPD1_Kglyc3p\" , km_product2 = \"p_GPD1_Knad\" , ka1 = \"p_GPD1_Kf16bp\" , ka2 = \"p_GPD1_Katp\" , ka3 = \"p_GPD1_Kadp\" , )) v_gapdh = jkm . Reaction ( name = \"v_GAPDH\" , species = [ 'ICGAP' , 'ICNAD' , 'ICPHOS' , 'ICBPG' , 'ICNADH' ], stoichiometry = [ - 1 , - 1 , - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MM_Ordered_Bi_Tri ( substrate1 = \"ICGAP\" , substrate2 = \"ICNAD\" , substrate3 = \"ICPHOS\" , product1 = \"ICBPG\" , product2 = \"ICNADH\" , vmax = \"p_GAPDH_Vmax\" , k_equilibrium = \"p_TDH1_Keq\" , km_substrate1 = \"p_TDH1_Kglyceral3p\" , km_substrate2 = \"p_TDH1_Knad\" , ki = \"p_TDH1_Kpi\" , km_product1 = \"p_TDH1_Kglycerate13bp\" , km_product2 = \"p_TDH1_Knadh\" )) v_pgk = jkm . Reaction ( name = \"v_PGK\" , species = [ 'ICBPG' , 'ICADP' , 'IC3PG' , 'ICATP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_BiBi ( substrate1 = \"ICBPG\" , substrate2 = \"ICADP\" , product1 = \"IC3PG\" , product2 = \"ICATP\" , vmax = \"p_PGK_VmPGK\" , k_equilibrium = \"p_PGK_KeqPGK\" , km_substrate1 = \"p_PGK_KmPGKBPG\" , km_substrate2 = \"p_PGK_KmPGKADP\" , km_product1 = \"p_PGK_KmPGKP3G\" , km_product2 = \"p_PGK_KmPGKATP\" , )) v_sink3pga = jkm . Reaction ( name = \"v_sink3PGA\" , species = [ 'IC3PG' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"IC3PG\" , v_sink = \"poly_sinkP3G\" , km_sink = \"km_sinkP3G\" )) mech_hor2 = jm . Jax_MM_Irrev_Uni ( substrate = \"ICG3P\" , vmax = \"p_HOR2_Vmax\" , km_substrate = \"p_HOR2_Kglyc3p\" ) mech_hor2 . add_modifier ( modifier . SimpleInhibitor ( inhibitor = \"ICPHOS\" , k_I = \"p_HOR2_Kpi\" )) ## look into how to deal with arbitrary arguments in compute() v_hor2 = jkm . Reaction ( name = \"v_HOR2\" , species = [ 'ICG3P' , 'ICglyc' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = mech_hor2 ) ### next up v_GlycT mech_glyct_ic = jm . Jax_Diffusion ( substrate = \"ICglyc\" , enzyme = \"f_GLYCEROL_e\" , transport_coef = \"p_GlycerolTransport\" ) v_glyct_ic = jkm . Reaction ( name = \"v_GlycT_IC\" , species = [ 'ICglyc' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = mech_glyct_ic ) mech_glyct_ec = jm . Jax_Diffusion ( substrate = \"ICglyc\" , enzyme = \"f_GLYCEROL_e\" , transport_coef = \"p_GlycerolTransport\" ) mech_glyct_ec . add_modifier ( modifier . BiomassModifier ( biomass = \"ECbiomass\" )) v_glyct_ec = jkm . Reaction ( name = \"v_GlycT_EC\" , species = [ 'ICglyc' , 'ECglyc' ], stoichiometry = [ 0 , 1 ], compartments = [ 'c' , 'e' ], mechanism = mech_glyct_ec ) v_pgm = jkm . Reaction ( name = \"v_PGM\" , species = [ 'IC3PG' , 'IC2PG' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"IC3PG\" , product = \"IC2PG\" , vmax = \"p_PGM_Vm\" , k_equilibrium = \"p_PGM_Keq\" , km_substrate = \"p_PGM_K3pg\" , km_product = \"p_PGM_K2pg\" , )) v_eno2 = jkm . Reaction ( name = \"v_ENO2\" , species = [ 'IC2PG' , 'ICPEP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Rev_UniUni ( substrate = \"IC2PG\" , product = \"ICPEP\" , vmax = \"p_ENO1_Vm\" , k_equilibrium = \"p_ENO1_Keq\" , km_substrate = \"p_ENO1_K2pg\" , km_product = \"p_ENO1_Kpep\" , )) v_sinkpep = jkm . Reaction ( name = \"v_sinkPEP\" , species = [ 'ICPEP' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICPEP\" , v_sink = \"poly_sinkPEP\" , km_sink = \"km_sinkPEP\" )) v_pyk1 = jkm . Reaction ( name = 'v_PYK1' , species = [ 'ICPEP' , 'ICADP' , 'ICPYR' , 'ICATP' , 'ICFBP' ], stoichiometry = [ - 1 , - 1 , 1 , 1 , 0 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_Hill_Irreversible_Bi_Activation ( substrate1 = \"ICPEP\" , substrate2 = \"ICADP\" , activator = \"ICFBP\" , product = \"ICATP\" , vmax = \"p_PYK1_Vm\" , hill = \"p_PYK1_hill\" , k_substrate1 = \"p_PYK1_Kpep\" , k_substrate2 = \"p_PYK1_Kadp\" , k_product = \"p_PYK1_Katp\" , k_activator = \"p_PYK1_Kf16bp\" , l = \"p_PYK1_L\" , )) v_sinkpyr = jkm . Reaction ( name = 'v_sinkPYR' , species = [ 'ICPYR' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICPYR\" , v_sink = \"poly_sinkPYR\" , km_sink = \"km_sinkPYR\" )) v_adh = jkm . Reaction ( name = 'v_ADH' , species = [ 'ICNAD' , 'ICETOH' , 'ICNADH' , 'ICACE' ], stoichiometry = [ 1 , 1 , - 1 , - 1 ], compartments = [ 'c' , 'c' , 'c' , 'c' ], mechanism = jcm . Jax_ADH ( NAD = \"ICNAD\" , ETOH = \"ICETOH\" , NADH = \"ICNADH\" , ACE = \"ICACE\" , vmax = \"p_ADH_VmADH\" , k_equilibrium = \"p_ADH_KeqADH\" , km_substrate1 = \"p_ADH_KiADHNAD\" , km_substrate2 = \"p_ADH_KmADHETOH\" , km_product1 = \"p_ADH_KmADHACE\" , km_product2 = \"p_ADH_KmADHNADH\" , ki_substrate1 = \"p_ADH_KiADHNAD\" , ki_substrate2 = \"p_ADH_KiADHETOH\" , ki_product1 = \"p_ADH_KiADHACE\" , ki_product2 = \"p_ADH_KiADHNADH\" , exprs_cor = \"p_ADH_ExprsCor\" , )) v_sinkace = jkm . Reaction ( name = 'v_sinkACE' , species = [ 'ICACE' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_MM_Sink ( substrate = \"ICACE\" , v_sink = \"poly_sinkACE\" , km_sink = \"km_sinkACE\" )) #from a modelling perspective this is awkward. we have a rate that only needs to be modified for ECETOH, not ICETOH. # where therefore need to split the stoichiometry as well, while maintaining the same parameters mech_etoht_ic = jm . Jax_Diffusion ( substrate = \"ICETOH\" , enzyme = \"f_ETOH_e\" , transport_coef = \"p_kETOHtransport\" ) Sometimes, a flux may need to be scaled differently per ODEs. Suppose we have the original mass-balances in the glycolysis model, where for the intracellular concentration we do not scale the flux, but for the extracellular we do. $$\\frac{d etoh_{ic}}{dt}=- v_{ETOHT} + ... $$ $$\\frac{d etoh_{ec}}{dt}=+ v_{ETOHT} * [biomass] * 0.002 + ... $$ We can first define a mechanisms for ICETOH and then modify this for ECETOH. This requires us to use two Reaction objects, and set stoichiometry to 0 to ensure that they are not wrongly affected by the scaling. #only outgoing v_etoht_ic = jkm . Reaction ( name = \"v_ETOHT_IC\" , species = [ 'ICETOH' ], stoichiometry = [ - 1 , 0 ], compartments = [ 'c' ], mechanism = mech_etoht_ic ) mech_etoht_ec = jm . Jax_Diffusion ( substrate = \"ICETOH\" , enzyme = \"f_ETOH_e\" , transport_coef = \"p_kETOHtransport\" ) mech_etoht_ec . add_modifier ( modifier . BiomassModifier ( biomass = 'ECbiomass' )) v_etoht_ec = jkm . Reaction ( name = \"v_ETOHT_EC\" , species = [ 'ICETOH' , 'ECETOH' ], stoichiometry = [ 0 , 1 ], compartments = [ 'c' , 'e' ], mechanism = mech_etoht_ec ) Further finish the reaction definitions v_atpmito = jkm . Reaction ( name = 'v_ATPMITO' , species = [ 'ICATP' , 'ICPHOS' , 'ICADP' ], stoichiometry = [ 1 , - 1 , - 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MM_Irrev_Bi ( substrate1 = \"ICADP\" , substrate2 = \"ICPHOS\" , vmax = \"p_mitoVmax\" , km_substrate1 = \"p_mitoADPKm\" , km_substrate2 = \"p_mitoPiKm\" )) v_atpase = jkm . Reaction ( name = \"v_ATPASE\" , species = [ 'ICATP' , 'ICPHOS' , 'ICADP' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jcm . Jax_ATPase ( substrate = \"ICATP\" , product = \"ICADP\" , ATPase_ratio = \"p_ATPase_ratio\" )) v_adk = jkm . Reaction ( name = \"v_ADK\" , species = [ 'ICADP' , 'ICATP' , 'ICAMP' ], stoichiometry = [ - 2 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jcm . Jax_MA_Rev_Bi ( substrate1 = \"ICADP\" , substrate2 = \"ICADP\" , product1 = \"ICATP\" , product2 = \"ICAMP\" , k_equilibrium = \"p_ADK1_Keq\" , k_fwd = \"p_ADK1_k\" )) v_vacpi = jkm . Reaction ( name = \"v_VACPI\" , species = [ 'ICPHOS' ], stoichiometry = [ 1 ], compartments = [ 'c' ], mechanism = jcm . Jax_MA_Rev ( substrate = \"ICPHOS\" , k = \"p_vacuolePi_k\" , steady_state_substrate = \"p_vacuolePi_steadyStatePi\" ) ) v_amd1 = jkm . Reaction ( name = \"v_AMD1\" , species = [ 'ICAMP' , 'ICIMP' , 'ICATP' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 , 0 , 0 ], compartments = [ 'c' , 'c' ], mechanism = jcm . Jax_Amd1 ( substrate = \"ICAMP\" , product = \"ICATP\" , modifier = \"ICPHOS\" , vmax = \"p_Amd1_Vmax\" , k50 = \"p_Amd1_K50\" , ki = \"p_Amd1_Kpi\" , k_atp = \"p_Amd1_Katp\" , )) v_ade1312 = jkm . Reaction ( name = \"v_ADE1312\" , species = [ 'ICIMP' , 'ICAMP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Ade13_Ade12_k\" )) v_isn1 = jkm . Reaction ( name = \"v_ISN1\" , species = [ 'ICIMP' , 'ICPHOS' , 'ICINO' ], stoichiometry = [ - 1 , 1 , 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICIMP\" , k_fwd = \"p_Isn1_k\" )) v_pnp1 = jkm . Reaction ( name = \"v_PNP1\" , species = [ 'ICINO' , 'ICHYP' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICINO\" , k_fwd = \"p_Pnp1_k\" )) v_hpt1 = jkm . Reaction ( name = \"v_HPT1\" , species = [ 'ICIMP' , 'ICPHOS' , 'ICHYP' ], stoichiometry = [ 1 , - 1 , - 1 ], compartments = [ 'c' , 'c' , 'c' ], mechanism = jm . Jax_MA_Irrev ( substrate = \"ICHYP\" , k_fwd = \"p_Hpt1_k\" )) #v_pdcs v_pdc = jkm . Reaction ( name = \"v_PDC\" , species = [ 'ICPYR' , 'ICACE' , 'ICPHOS' ], stoichiometry = [ - 1 , 1 , 0 ], compartments = [ 'c' , 'c' ], mechanism = jcm . Jax_Hill_Irreversible_Inhibition ( substrate = \"ICPYR\" , inhibitor = \"ICPHOS\" , vmax = \"p_PDC1_Vmax\" , k_half_substrate = \"p_PDC1_Kpyr\" , hill = \"p_PDC1_hill\" , ki = \"p_PDC1_Kpi\" , )) v_mitonadh = jkm . Reaction ( name = \"v_MITONADH\" , species = [ 'ICNADH' , 'ICNAD' ], stoichiometry = [ - 1 , 1 ], compartments = [ 'c' , 'c' ], mechanism = jm . Jax_MM ( substrate = \"ICNADH\" , vmax = \"p_mitoNADHVmax\" , km = \"p_mitoNADHKm\" )) # I think this can be replaced by Jax_MM_Irrev_Uni v_ugp = jkm . Reaction ( name = \"v_UGP\" , species = [ 'ICG1P' ], stoichiometry = [ - 1 ], compartments = [ 'c' ], mechanism = jm . Jax_Constant_Flux ( v = \"flux_ugp\" )) #modification to mimic the glycolysis model v_transport_reactions = jkm . Reaction ( name = \"v_TRANSPORT\" , species = [ 'ECETOH' , 'ECglyc' ], compartments = [ 'e' , 'e' ], stoichiometry = [ - 1 , - 1 ], mechanism = jcm . Jax_Transport_Flux_Correction ( substrate = \"ECETOH\" , dilution_rate = 'D' ) )","title":"Rate laws"},{"location":"glycolysis/#setting-up-the-ode-system","text":"We now pass all reactions and compartment definitions to JaxKineticModelBuild , similarly to how it was performed in the Building Models tutorial. ## we can add modifications to mechanism through the JaxKineticModelBuild obejct compartments = { 'c' : 1 , 'e' : 1 } reactions = [ v_hxk , v_glt , v_nth1 , v_pgi , v_sinkg6p , v_sinkf6p , v_pgm1 , v_tps1 , v_tps2 , v_pfk , v_ald , v_tpi1 , v_sinkgap , v_g3pdh , v_gapdh , v_pgk , v_sink3pga , v_hor2 , v_glyct_ic , v_glyct_ec , v_pgm , v_eno2 , v_sinkpep , v_pyk1 , v_sinkpyr , v_adh , v_sinkace , v_etoht_ic , v_etoht_ec , v_atpmito , v_atpase , v_adk , v_vacpi , v_amd1 , v_ade1312 , v_isn1 , v_pnp1 , v_hpt1 , v_pdc , v_mitonadh , v_ugp , v_transport_reactions ] kmodel = jkm . JaxKineticModelBuild ( reactions , compartments )","title":"Setting up the ODE system"},{"location":"glycolysis/#cubic-spline-boundary-condition","text":"As mentioned in the Building Models tutorial, we can add boundary conditions for species that are either constant or time-dependent. Often, it is necessary to do interpolation, such as cubic spline, to model a perturbation. We can build expressions for that using sympy, pass these as a string input to the boundary condition class, which builds the cubic spline for us, that can be exported to an sbml. # do an interpolation using sympy for EC glucose and add as a boundary condition data = pd . read_csv ( 'datasets/VanHeerden_Glucose_Pulse/FF1_timeseries_format.csv' , index_col = 0 ) domain = [ float ( i ) for i in data . loc [ 'ECglucose' ] . dropna () . index ] d_range = data . loc [ 'ECglucose' ] . dropna () . values t = sympy . Symbol ( 't' ) spline = sympy . interpolating_spline ( 3 , t , domain , d_range ) print ( 'true spline' , spline ) spline = str ( spline ) kmodel . add_boundary ( 'ECglucose' , jkm . BoundaryCondition ( spline ))","title":"Cubic spline boundary condition"},{"location":"glycolysis/#parameters-and-initial-conditions","text":"We add parameters from literature values and the initial conditions are initialized. kmodel_sim = jkm . NeuralODEBuild ( kmodel ) S = kmodel . stoichiometric_matrix lit_params = pd . read_csv (( 'parameter_initializations/' 'Glycolysis_model/' 'parameter_initialization_glycolysis' '_literature_values.csv' ), index_col = 0 ) . to_dict ()[ '0' ] D = 0.1 parameters = {} for name in kmodel . parameter_names : #need to deal with the poly_sinks dependent on dilution rate if name in lit_params . keys (): parameters [ name ] = lit_params [ name ] else : if name == 'poly_sinkG6P' : parameters [ name ] = float ( jnp . abs ( 3.6854 * D ** 3 - 1.4119 * D ** 2 - 0.6312 * D - 0.0043 )) elif name == 'poly_sinkF6P' : parameters [ name ] = float ( jnp . abs ( 519.3740 * D ** 6 - 447.7990 * D ** 5 + 97.2843 * D ** 4 + 8.0698 * D ** 3 - 4.4005 * D ** 2 + 0.6254 * D - 0.0078 )) elif name == 'poly_sinkP3G' : parameters [ name ] = float ( jnp . abs ( - 0.2381 * D ** 2 - 0.0210 * D - 0.0034 )) elif name == 'poly_sinkPEP' : parameters [ name ] = float ( jnp . abs ( - 0.0637 * D ** 2 - 0.0617 * D - 0.0008 )) elif name == 'poly_sinkPYR' : parameters [ name ] = float ( jnp . abs ( - 8.4853e03 * D ** 6 + 9.4027e03 * D ** 5 - 3.8027e03 * D ** 4 + 700.5 * D ** 3 - 60.26 * D ** 2 + 0.711 * D - 0.0356 )) elif name == 'poly_sinkACE' : parameters [ name ] = float ( jnp . abs ( 118.8562 * D ** 6 - 352.3943 * D ** 5 + 245.6092 * D ** 4 - 75.2550 * D ** 3 + 11.1153 * D ** 2 - 1.0379 * D + 0.0119 )) elif name == 'ECbiomass' : parameters [ name ] = float ( 3.7683659 ) elif name == \"D\" : parameters [ name ] = float ( D ) y0_dict = { \"ICG1P\" : 0.064568 , \"ICT6P\" : 0.093705 , \"ICtreh\" : 63.312040 , \"ICglucose\" : 0.196003 , \"ICG6P\" : 0.716385 , \"ICF6P\" : 0.202293 , \"ICFBP\" : 0.057001 , \"ICDHAP\" : 0.048571 , \"ICG3P\" : 0.020586 , \"ICglyc\" : 0.1 , \"ICGAP\" : 0.006213 , \"ICBPG\" : 0.0001 , \"IC3PG\" : 2.311074 , \"IC2PG\" : 0.297534 , \"ICPEP\" : 1.171415 , \"ICPYR\" : 0.152195 , \"ICACE\" : 0.04 , \"ICETOH\" : 10.0 , \"ECETOH\" : 0 , \"ECglyc\" : 0.0 , \"ICNADH\" : 0.0106 , \"ICNAD\" : 1.5794 , \"ICATP\" : 3.730584 , \"ICADP\" : 1.376832 , \"ICAMP\" : 0.431427 , \"ICPHOS\" : 10 , \"ICIMP\" : 0.100 , \"ICINO\" : 0.100 , \"ICHYP\" : 1.5 , } y0 = [] for meta in kmodel . species_names : if meta in y0_dict . keys (): y0 . append ( y0_dict [ meta ]) else : print ( meta ) y0 . append ( 1 ) y0 = jnp . array ( y0 )","title":"Parameters and initial conditions"},{"location":"glycolysis/#exporting-the-model","text":"The model can be exported to sbml format for parameter optimziation. output_dir = \"models/manual_implementations/sbml_export/\" model_name = \"glycolysis_feastfamine_pulse1\" sbml = SBMLExporter ( model = kmodel_sim ) sbml . export ( initial_conditions = y0 , parameters = parameters , output_file = f \" { output_dir } / { model_name } .xml\" )","title":"Exporting the model"},{"location":"glycolysis/#references","text":"[1] Lao-Martil, D., Schmitz, J. P., Teusink, B., & van Riel, N. A. (2023). Elucidating yeast glycolytic dynamics at steady state growth and glucose pulses through kinetic metabolic modeling. Metabolic engineering, 77, 128-142.","title":"References"},{"location":"simulated-DBTL/","text":"Simulated design-build-test-learn-cycles A simulation of metabolic engineering experiments DBTL cycles are widely used in the optimization of microorganisms for producing valuable compounds in a sustainable way. Despite the widespread use, many open questions exist when it comes to effectively using DBTL cycles. The reason for this is that due to the costly nature (in terms of time and money), effectively comparing design choices is never considered. It is for example highly unlikely that for the same optimization process, different sampling scenarios are compared, even though this might be valuable. An alternative cheap way to answer these types of questions is by simulating DBTL cycles [1] . Here, we show a reimplemented software of simulated-DBTL in Jax/Diffrax [2] . This allows users to test scenarios for their own lab settings. Figure 1: The design-build-test-learn cycle of iterative metabolic engineering, a widely adopted paradigm for strain engineering. Usage Import required functions from jaxkineticmodel.load_sbml.sbml_model import SBMLModel , get_global_parameters import jax.numpy as jnp from jaxkineticmodel.utils import get_logger logger = get_logger ( __name__ ) from jaxkineticmodel.simulated_dbtl.dbtl import DesignBuildTestLearnCycle We first choose a kinetic model that we consider only as a black-box that outputs some target value. From this model scenarios are simulated that might be encountered in real metabolic engineering. At the heart of this implementation is the DesignBuildTestLearnCycle . This requires setting the initial parameters (the reference state), initial conditions, the timespan of process, and the target that we wish to simulate. # load model (Messiha et. al (2013)) filepath = ( \"models/sbml_models/working_models/Messiha2013.xml\" ) model = SBMLModel ( filepath ) # we retrieve parameters from the model # timespan of model ts = jnp . linspace ( 0 , 6000 , 100 ) dbtl_cycle = DesignBuildTestLearnCycle ( model = model , parameters = model . parameters , initial_conditions = model . y0 , timespan = ts , target = [ 'PEP' ]) # design phase Design phase We now set up the combinatorial pathway optimization experiment. We define some parameter targets that we want to perturb. Then, each target gets some \"promoter\" values that perturb the parameters by multiplication. Then, we assign probabilities to each promoter-parameter values. If this function is empty, each promoter-parameter is equally probable. Finally, we generate the designs, for 40 samples and 5 chosen pro-parameter elements. # design phase parameter_target_names = [ 'lp.ADH.Kacald' , 'lp.ENO.kcat_ENO1' , 'lp.FBA.Kdhap' , 'lp.HXK.kcat_HXK1' , 'lp.PGK.kcat' , 'lp.HXT.Vmax' , 'lp.GND.Kp6g_GND1' ] parameter_perturbation_value = [[ 0.2 , 0.5 , 1 , 1.5 , 2 ], # 'lp.ADH.Kacald' [ 1.2 , 1.5 , 1.8 ], # 'lp.ENO.kcat_ENO1' [ 1.1 , 1.6 , 1.3 ], # 'lp.FBA.Kdhap' [ 0.6 , 1.1 , 2 , 3 ], # 'lp.HXK.kcat_HXK1' [ 1 , 2 , 3 ], # 'lp.PGK.kcat' [ 0.5 , 1 , 1.5 ], # 'lp.HXT.Vmax' [ 2 , 3 , 4 ]] # 'lp.GND.Kp6g_GND1' dbtl_cycle . design_establish_library_elements ( parameter_target_names , parameter_perturbation_value ) dbtl_cycle . design_assign_probabilities () # The replacement is false means that each pro-parameter # pair can only be chosen once from the list per strain design strain_designs = dbtl_cycle . design_generate_strains ( elements = 6 , samples = 40 , replacement = False ) Build/Test phase In the build phase we simulate all the designs and add a noise model to the outcomes for the target. The first simulation will take quite long, but after that it is compiled. If you do not run the class DesignBuildTestLearnCycle again, the simulations remain fast. The values that are taken in the dataset is the average of the last 10 datapoints of the target state variable. # build phase values = dbtl_cycle . build_simulate_strains ( strain_designs , plot = False ) # test phase noised_values = dbtl_cycle . test_add_noise ( values , 0.1 , noisetype = 'heteroschedastic' ) data = dbtl_cycle . test_format_dataset ( strain_designs = strain_designs , production_values = noised_values , reference_parameters = dbtl_cycle . parameters ) # learn phase Learn phase From here, the produced data can be used to compare whatever hyperparameter of the DBTL cycle you are interested: the performance of ML models, DoE v.s. Random sampling, etc.. As an example, we train an XGBoost model on the set of generated datapoints, as well as a quick validation on newly generated strain designs. # learn phase xgbparameters = { 'tree_method' : 'auto' , 'reg_lambda' : 1 , 'max_depth' : 2 , \"disable_default_eval_metric\" : 0 } alternative_params = { 'num_boost_round' : 10 , 'early_stopping_rounds' : 40 } bst , r2_scores = dbtl_cycle . learn_train_model ( data = data , target = \"PEP\" , model_type = \"XGBoost\" , args = ( xgbparameters , alternative_params ), test_size = 0.20 ) dbtl_cycle . learn_validate_model ( samples = 12 , elements = 12 , target = 'PEP' , plotting = True ) Figure 2: Model performance (true versups predicted values). References [1] van Lent, P., Schmitz, J., & Abeel, T. (2023). Simulated design\u2013build\u2013test\u2013learn cycles for consistent comparison of machine learning methods in metabolic engineering. ACS Synthetic Biology, 12(9), 2588-2599. [2] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435.","title":"Simulated-DBTL"},{"location":"simulated-DBTL/#simulated-design-build-test-learn-cycles","text":"","title":"Simulated design-build-test-learn-cycles"},{"location":"simulated-DBTL/#a-simulation-of-metabolic-engineering-experiments","text":"DBTL cycles are widely used in the optimization of microorganisms for producing valuable compounds in a sustainable way. Despite the widespread use, many open questions exist when it comes to effectively using DBTL cycles. The reason for this is that due to the costly nature (in terms of time and money), effectively comparing design choices is never considered. It is for example highly unlikely that for the same optimization process, different sampling scenarios are compared, even though this might be valuable. An alternative cheap way to answer these types of questions is by simulating DBTL cycles [1] . Here, we show a reimplemented software of simulated-DBTL in Jax/Diffrax [2] . This allows users to test scenarios for their own lab settings. Figure 1: The design-build-test-learn cycle of iterative metabolic engineering, a widely adopted paradigm for strain engineering.","title":"A simulation of metabolic engineering experiments"},{"location":"simulated-DBTL/#usage","text":"Import required functions from jaxkineticmodel.load_sbml.sbml_model import SBMLModel , get_global_parameters import jax.numpy as jnp from jaxkineticmodel.utils import get_logger logger = get_logger ( __name__ ) from jaxkineticmodel.simulated_dbtl.dbtl import DesignBuildTestLearnCycle We first choose a kinetic model that we consider only as a black-box that outputs some target value. From this model scenarios are simulated that might be encountered in real metabolic engineering. At the heart of this implementation is the DesignBuildTestLearnCycle . This requires setting the initial parameters (the reference state), initial conditions, the timespan of process, and the target that we wish to simulate. # load model (Messiha et. al (2013)) filepath = ( \"models/sbml_models/working_models/Messiha2013.xml\" ) model = SBMLModel ( filepath ) # we retrieve parameters from the model # timespan of model ts = jnp . linspace ( 0 , 6000 , 100 ) dbtl_cycle = DesignBuildTestLearnCycle ( model = model , parameters = model . parameters , initial_conditions = model . y0 , timespan = ts , target = [ 'PEP' ]) # design phase","title":"Usage"},{"location":"simulated-DBTL/#design-phase","text":"We now set up the combinatorial pathway optimization experiment. We define some parameter targets that we want to perturb. Then, each target gets some \"promoter\" values that perturb the parameters by multiplication. Then, we assign probabilities to each promoter-parameter values. If this function is empty, each promoter-parameter is equally probable. Finally, we generate the designs, for 40 samples and 5 chosen pro-parameter elements. # design phase parameter_target_names = [ 'lp.ADH.Kacald' , 'lp.ENO.kcat_ENO1' , 'lp.FBA.Kdhap' , 'lp.HXK.kcat_HXK1' , 'lp.PGK.kcat' , 'lp.HXT.Vmax' , 'lp.GND.Kp6g_GND1' ] parameter_perturbation_value = [[ 0.2 , 0.5 , 1 , 1.5 , 2 ], # 'lp.ADH.Kacald' [ 1.2 , 1.5 , 1.8 ], # 'lp.ENO.kcat_ENO1' [ 1.1 , 1.6 , 1.3 ], # 'lp.FBA.Kdhap' [ 0.6 , 1.1 , 2 , 3 ], # 'lp.HXK.kcat_HXK1' [ 1 , 2 , 3 ], # 'lp.PGK.kcat' [ 0.5 , 1 , 1.5 ], # 'lp.HXT.Vmax' [ 2 , 3 , 4 ]] # 'lp.GND.Kp6g_GND1' dbtl_cycle . design_establish_library_elements ( parameter_target_names , parameter_perturbation_value ) dbtl_cycle . design_assign_probabilities () # The replacement is false means that each pro-parameter # pair can only be chosen once from the list per strain design strain_designs = dbtl_cycle . design_generate_strains ( elements = 6 , samples = 40 , replacement = False )","title":"Design phase"},{"location":"simulated-DBTL/#buildtest-phase","text":"In the build phase we simulate all the designs and add a noise model to the outcomes for the target. The first simulation will take quite long, but after that it is compiled. If you do not run the class DesignBuildTestLearnCycle again, the simulations remain fast. The values that are taken in the dataset is the average of the last 10 datapoints of the target state variable. # build phase values = dbtl_cycle . build_simulate_strains ( strain_designs , plot = False ) # test phase noised_values = dbtl_cycle . test_add_noise ( values , 0.1 , noisetype = 'heteroschedastic' ) data = dbtl_cycle . test_format_dataset ( strain_designs = strain_designs , production_values = noised_values , reference_parameters = dbtl_cycle . parameters ) # learn phase","title":"Build/Test phase"},{"location":"simulated-DBTL/#learn-phase","text":"From here, the produced data can be used to compare whatever hyperparameter of the DBTL cycle you are interested: the performance of ML models, DoE v.s. Random sampling, etc.. As an example, we train an XGBoost model on the set of generated datapoints, as well as a quick validation on newly generated strain designs. # learn phase xgbparameters = { 'tree_method' : 'auto' , 'reg_lambda' : 1 , 'max_depth' : 2 , \"disable_default_eval_metric\" : 0 } alternative_params = { 'num_boost_round' : 10 , 'early_stopping_rounds' : 40 } bst , r2_scores = dbtl_cycle . learn_train_model ( data = data , target = \"PEP\" , model_type = \"XGBoost\" , args = ( xgbparameters , alternative_params ), test_size = 0.20 ) dbtl_cycle . learn_validate_model ( samples = 12 , elements = 12 , target = 'PEP' , plotting = True ) Figure 2: Model performance (true versups predicted values).","title":"Learn phase"},{"location":"simulated-DBTL/#references","text":"[1] van Lent, P., Schmitz, J., & Abeel, T. (2023). Simulated design\u2013build\u2013test\u2013learn cycles for consistent comparison of machine learning methods in metabolic engineering. ACS Synthetic Biology, 12(9), 2588-2599. [2] Kidger, P. (2022). On neural differential equations. arXiv preprint arXiv:2202.02435.","title":"References"},{"location":"training_models/","text":"Training metabolic kinetic models Here, we showcase an parameter optimization process with simulated data [1] . The Trainer object The Trainer object requires a few inputs. First, it requires a SBMLModel or a NeuralODEBuild object to be used. The second input is a datasets to fit on. Here, we show the fitting of a previously reported Serine Biosynthesis model [1] . Setting up the trainer object + training First, we load the necessary functions from jaxkineticmodel.parameter_estimation.training import Trainer from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import numpy as np import matplotlib.pyplot as plt import pandas as pd import jax.numpy as jnp from jaxkineticmodel.parameter_estimation.training import exponentiate_parameters import optax Then, we load the model, data and initialize the trainer object. # load model model_name = \"Smallbone2013_SerineBiosynthesis\" filepath = \"models/sbml_models/working_models/\" + model_name + \".xml\" model = SBMLModel ( filepath ) # load data dataset = pd . read_csv ( \"datasets/Smallbone2013 - Serine biosynthesis/Smallbone2013 - Serine biosynthesis_dataset.csv\" , index_col = 0 ) #initialize the trainer object. The required inputs are model and data. We will do 300 iterations of gradient descent trainer = Trainer ( model = model , data = dataset , n_iter = 300 ) # latin hypercube base_parameters = dict ( zip ( trainer . parameters , np . ones ( len ( trainer . parameters )))) We next perform a latin hypercube sampling for a certain initial guess, with lower and upperbound defined with respect to these values. We want five initializations (normally this should be higher). base_parameters = dict ( zip ( trainer . parameters , np . ones ( len ( trainer . parameters )))) parameter_sets = trainer . latinhypercube_sampling ( base_parameters , lower_bound = 1 / 10 , upper_bound = 10 , N = 5 ) optimized_parameters , loss_per_iteration , global_norms = trainer . train () To initiate training, you simply call the function Trainer.train() fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): ax . plot ( loss_per_iteration [ i ]) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () Figure 1: Loss per iteration for five initializations. Additional rounds Suppose the fit is not to your liking, or we first want to do a pre-optimization of a large set of parameters and then filter promising sets, one can continue the optimization by re-running the trainer object with the set of optimized parameters. # next round params_round1 = pd . DataFrame ( optimized_parameters ) . T trainer . parameter_sets = params_round1 trainer . n_iter = 500 optimized_parameters2 , loss_per_iteration2 , global_norms2 = trainer . train () # plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): plt . plot ( np . concatenate (( np . array ( loss_per_iteration [ i ]), loss_per_iteration2 [ i ]))) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () # fig.savefig(\"docs/docs/images/loss_per_iter_extended.png\",bbox_inches=\"tight\") Figure 2: Loss per iteration for five initializations, extended with 500 rounds of gradient descent. Trainer configurability Optimization in logarithmic or linear space Optimization in logarithmic space has shown to work well for systems biology models[2] and is implemented as the default. To change to using gradient descent in a linear parameter space, you can restart the Trainer object. When the loss function is not specified (see below), a mean squared error loss is used. # log or linear space example trainer = Trainer ( model = model , data = dataset , n_iter = 300 , optim_space = \"linear\" ) Optimizer choices Jaxkineticmodel is compatible with optimizers from optax . To use these, simply pass the optimizer to the Trainer object (with required arguments). # optimizer change with optax optimizers trainer = Trainer ( model = model , data = dataset , n_iter = 300 , optimizer = optax . adam ( lr = 1e-3 )) Customize loss functions Jaxkinetic model uses as a default a log-transformed parameter space and a mean centered loss function. However, users may want to present their own custom loss. # own loss function def log_mean_centered_loss_func2 ( params , ts , ys , model , to_include ): \"\"\"log_mean_centered_loss_func with index of state variables on which to train on. For example in the case of incomplete knowledge of the system\"\"\" params = exponentiate_parameters ( params ) mask = ~ jnp . isnan ( jnp . array ( ys )) ys = jnp . atleast_2d ( ys ) y0 = ys [ 0 , :] y_pred = model ( ts , y0 , params ) ys = jnp . where ( mask , ys , 0 ) ys += 1 y_pred += 1 scale = jnp . mean ( ys , axis = 0 ) ys /= scale y_pred /= scale y_pred = jnp . where ( mask , y_pred , 0 ) ys = ys [:, to_include ] y_pred = y_pred [:, to_include ] non_nan_count = jnp . sum ( mask ) loss = jnp . sum (( y_pred - ys ) ** 2 ) / non_nan_count return loss trainer = Trainer ( model = model , data = dataset , n_iter = 300 ) trainer . _create_loss_func ( log_mean_centered_loss_func2 , to_include = [ 0 ]) #only include specimen 1 in the dataset The loss function has mandatory arguments params , ts , ys . All other required arguments (e.g., to_include ) are passed to trainer._create_loss_func() NOTE: the use of custom loss function can depend on whether you perform your optimization in log-space or not. If you want to perform a custom loss function in log-space, you need to exponentiate your parameters within the loss function. Future configuration options We aim to further add configurability of the adjoint option from Diffrax. References [1] Smallbone, K., & Stanford, N. J. (2013). Kinetic modeling of metabolic pathways: Application to serine biosynthesis. Systems Metabolic Engineering: Methods and Protocols, 113-121. [2] Villaverde, A. F., Fr\u00f6hlich, F., Weindl, D., Hasenauer, J., & Banga, J. R. (2019). Benchmarking optimization methods for parameter estimation in large kinetic models. Bioinformatics, 35(5), 830-838.","title":"Training models"},{"location":"training_models/#training-metabolic-kinetic-models","text":"Here, we showcase an parameter optimization process with simulated data [1] .","title":"Training metabolic kinetic models"},{"location":"training_models/#the-trainer-object","text":"The Trainer object requires a few inputs. First, it requires a SBMLModel or a NeuralODEBuild object to be used. The second input is a datasets to fit on. Here, we show the fitting of a previously reported Serine Biosynthesis model [1] .","title":"The Trainer object"},{"location":"training_models/#setting-up-the-trainer-object-training","text":"First, we load the necessary functions from jaxkineticmodel.parameter_estimation.training import Trainer from jaxkineticmodel.load_sbml.sbml_model import SBMLModel import numpy as np import matplotlib.pyplot as plt import pandas as pd import jax.numpy as jnp from jaxkineticmodel.parameter_estimation.training import exponentiate_parameters import optax Then, we load the model, data and initialize the trainer object. # load model model_name = \"Smallbone2013_SerineBiosynthesis\" filepath = \"models/sbml_models/working_models/\" + model_name + \".xml\" model = SBMLModel ( filepath ) # load data dataset = pd . read_csv ( \"datasets/Smallbone2013 - Serine biosynthesis/Smallbone2013 - Serine biosynthesis_dataset.csv\" , index_col = 0 ) #initialize the trainer object. The required inputs are model and data. We will do 300 iterations of gradient descent trainer = Trainer ( model = model , data = dataset , n_iter = 300 ) # latin hypercube base_parameters = dict ( zip ( trainer . parameters , np . ones ( len ( trainer . parameters )))) We next perform a latin hypercube sampling for a certain initial guess, with lower and upperbound defined with respect to these values. We want five initializations (normally this should be higher). base_parameters = dict ( zip ( trainer . parameters , np . ones ( len ( trainer . parameters )))) parameter_sets = trainer . latinhypercube_sampling ( base_parameters , lower_bound = 1 / 10 , upper_bound = 10 , N = 5 ) optimized_parameters , loss_per_iteration , global_norms = trainer . train () To initiate training, you simply call the function Trainer.train() fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): ax . plot ( loss_per_iteration [ i ]) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () Figure 1: Loss per iteration for five initializations.","title":"Setting up the trainer object + training"},{"location":"training_models/#additional-rounds","text":"Suppose the fit is not to your liking, or we first want to do a pre-optimization of a large set of parameters and then filter promising sets, one can continue the optimization by re-running the trainer object with the set of optimized parameters. # next round params_round1 = pd . DataFrame ( optimized_parameters ) . T trainer . parameter_sets = params_round1 trainer . n_iter = 500 optimized_parameters2 , loss_per_iteration2 , global_norms2 = trainer . train () # plot fig , ax = plt . subplots ( figsize = ( 3 , 3 )) for i in range ( 5 ): plt . plot ( np . concatenate (( np . array ( loss_per_iteration [ i ]), loss_per_iteration2 [ i ]))) ax . set_xlabel ( \"Iterations\" ) ax . set_ylabel ( \"Log Loss\" ) ax . set_yscale ( \"log\" ) plt . show () # fig.savefig(\"docs/docs/images/loss_per_iter_extended.png\",bbox_inches=\"tight\") Figure 2: Loss per iteration for five initializations, extended with 500 rounds of gradient descent.","title":"Additional rounds"},{"location":"training_models/#trainer-configurability","text":"","title":"Trainer configurability"},{"location":"training_models/#optimization-in-logarithmic-or-linear-space","text":"Optimization in logarithmic space has shown to work well for systems biology models[2] and is implemented as the default. To change to using gradient descent in a linear parameter space, you can restart the Trainer object. When the loss function is not specified (see below), a mean squared error loss is used. # log or linear space example trainer = Trainer ( model = model , data = dataset , n_iter = 300 , optim_space = \"linear\" )","title":"Optimization in logarithmic or linear space"},{"location":"training_models/#optimizer-choices","text":"Jaxkineticmodel is compatible with optimizers from optax . To use these, simply pass the optimizer to the Trainer object (with required arguments). # optimizer change with optax optimizers trainer = Trainer ( model = model , data = dataset , n_iter = 300 , optimizer = optax . adam ( lr = 1e-3 ))","title":"Optimizer choices"},{"location":"training_models/#customize-loss-functions","text":"Jaxkinetic model uses as a default a log-transformed parameter space and a mean centered loss function. However, users may want to present their own custom loss. # own loss function def log_mean_centered_loss_func2 ( params , ts , ys , model , to_include ): \"\"\"log_mean_centered_loss_func with index of state variables on which to train on. For example in the case of incomplete knowledge of the system\"\"\" params = exponentiate_parameters ( params ) mask = ~ jnp . isnan ( jnp . array ( ys )) ys = jnp . atleast_2d ( ys ) y0 = ys [ 0 , :] y_pred = model ( ts , y0 , params ) ys = jnp . where ( mask , ys , 0 ) ys += 1 y_pred += 1 scale = jnp . mean ( ys , axis = 0 ) ys /= scale y_pred /= scale y_pred = jnp . where ( mask , y_pred , 0 ) ys = ys [:, to_include ] y_pred = y_pred [:, to_include ] non_nan_count = jnp . sum ( mask ) loss = jnp . sum (( y_pred - ys ) ** 2 ) / non_nan_count return loss trainer = Trainer ( model = model , data = dataset , n_iter = 300 ) trainer . _create_loss_func ( log_mean_centered_loss_func2 , to_include = [ 0 ]) #only include specimen 1 in the dataset The loss function has mandatory arguments params , ts , ys . All other required arguments (e.g., to_include ) are passed to trainer._create_loss_func() NOTE: the use of custom loss function can depend on whether you perform your optimization in log-space or not. If you want to perform a custom loss function in log-space, you need to exponentiate your parameters within the loss function.","title":"Customize loss functions"},{"location":"training_models/#future-configuration-options","text":"We aim to further add configurability of the adjoint option from Diffrax.","title":"Future configuration options"},{"location":"training_models/#references","text":"[1] Smallbone, K., & Stanford, N. J. (2013). Kinetic modeling of metabolic pathways: Application to serine biosynthesis. Systems Metabolic Engineering: Methods and Protocols, 113-121. [2] Villaverde, A. F., Fr\u00f6hlich, F., Weindl, D., Hasenauer, J., & Banga, J. R. (2019). Benchmarking optimization methods for parameter estimation in large kinetic models. Bioinformatics, 35(5), 830-838.","title":"References"}]}